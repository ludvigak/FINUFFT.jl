var documenterSearchIndex = {"docs":
[{"location":"#FINUFFT.jl-Reference","page":"FINUFFT.jl Reference","title":"FINUFFT.jl Reference","text":"","category":"section"},{"location":"","page":"FINUFFT.jl Reference","title":"FINUFFT.jl Reference","text":"For installation and basic usage, see the README at https://github.com/ludvigak/FINUFFT.jl","category":"page"},{"location":"","page":"FINUFFT.jl Reference","title":"FINUFFT.jl Reference","text":"For documentation of the library functions that are being called, see the FINUFFT documentation at https://finufft.readthedocs.io","category":"page"},{"location":"#Index","page":"FINUFFT.jl Reference","title":"Index","text":"","category":"section"},{"location":"","page":"FINUFFT.jl Reference","title":"FINUFFT.jl Reference","text":"","category":"page"},{"location":"#Types","page":"FINUFFT.jl Reference","title":"Types","text":"","category":"section"},{"location":"#FINUFFT.cufinufft_opts","page":"FINUFFT.jl Reference","title":"FINUFFT.cufinufft_opts","text":"mutable struct cufinufft_opts\n    upsampfac            :: Cdouble # upsampling ratio sigma, only 2.0 (standard) is implemented\n    # following options are for gpu #\n    gpu_method           :: Cint # 1: nonuniform-pts driven, 2: shared mem (SM)\n    gpu_sort             :: Cint # when NU-pts driven: 0: no sort (GM), 1: sort (GM-sort)\n    gpu_binsizex         :: Cint # used for 2D, 3D subproblem method\n    gpu_binsizey         :: Cint\n    gpu_binsizez         :: Cint\n    gpu_obinsizex        :: Cint # used for 3D spread block gather method\n    gpu_obinsizey        :: Cint\n    gpu_obinsizez        :: Cint\n    gpu_maxsubprobsize   :: Cint\n    gpu_kerevalmeth      :: Cint # 0: direct exp(sqrt()), 1: Horner ppval\n    gpu_spreadinterponly :: Cint # 0: NUFFT, 1: spread or interpolation only\n    gpu_maxbatchsize     :: Cint\n    # multi-gpu support #\n    gpu_device_id        :: Cint\n    gpu_stream           :: Ptr{Cvoid}\n    modeord              :: Cint # (type 1,2 only): 0 CMCL-style increasing mode order\n                                 #                  1 FFT-style mode order\n    debug                :: Cint # 0: no debug, 1: debug\nend\n\nOptions struct passed to cuFINUFFT, see C documentation.\n\n\n\n\n\n","category":"type"},{"location":"#FINUFFT.nufft_opts","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft_opts","text":"mutable struct nufft_opts\n    modeord            :: Cint\n    spreadinterponly   :: Cint\n    debug              :: Cint\n    spread_debug       :: Cint\n    showwarn           :: Cint\n    nthreads           :: Cint\n    fftw               :: Cint\n    spread_sort        :: Cint\n    spread_kerevalmeth :: Cint\n    spread_kerpad      :: Cint\n    upsampfac          :: Cdouble\n    spread_thread      :: Cint\n    maxbatchsize       :: Cint\n    spread_nthr_atomic :: Cint\n    spread_max_sp_size :: Cint\n    fftw_lock_fun      :: Ptr{Cvoid}\n    fftw_unlock_fun    :: Ptr{Cvoid}\n    fftw_lock_data     :: Ptr{Cvoid}\nend\n\nOptions struct passed to the FINUFFT library.\n\nFields\n\nThis is a summary only; see FINUFFT documentation for full descriptions.\n\nmodeord :: Cint\n\n0: CMCL-style increasing mode ordering (neg to pos), or\n1: FFT-style mode ordering (affects type-1,2 only)\n\nspreadinterponly :: Cint\n\n(type 1,2 only) \n0: do actual NUFFT \n1: only spread (if type 1) or interpolate (type 2) \n     debug :: Cint 0 silent, 1 some timing/debug, or 2 more\n\nspread_debug :: Cint\n\nspreader: 0 silent, 1 some timing/debug, or 2 tonnes\n\nshowwarn :: Cint\n\n0 don't print warnings to stderr, 1 do\n\nnthreads :: Cint\n\nnumber of threads to use, or 0 uses all available\n\nfftw :: Cint\n\nplan flags to FFTW (FFTWESTIMATE=64, FFTWMEASURE=0,...)\n\nspread_sort :: Cint\n\nspreader: 0 don't sort, 1 do, or 2 heuristic choice\n\nspread_kerevalmeth :: Cint\n\nspreader: 0 exp(sqrt()), 1 Horner piecewise poly (faster)\n\nspread_kerpad :: Cint\n\n(exp(sqrt()) only): 0 don't pad kernel to 4n, 1 do\n\nupsampfac :: Cdouble\n\nupsampling ratio sigma: 2.0 std, 1.25 small FFT, 0.0 auto\n\nspread_thread :: Cint\n\n(vectorized ntr>1 only)\n0: auto\n1: seq multithreaded\n2: parallel single-thread spread\n\nmaxbatchsize :: Cint\n\n(vectorized ntr>1 only): max transform batch, 0 auto\n\nspread_nthr_atomic :: Cint\n\nif >=0, threads above which spreader OMP critical goes atomic\n\nspread_max_sp_size :: Cint\n\nif >0, overrides spreader (dir=1) max subproblem size\n\nfftw_lock_fun      :: Ptr{Cvoid}\n\nFunction ptr that locks the FFTW planner \nC signature: void (*fftw_lock_fun)(void *)\n\nfftw_unlock_fun    :: Ptr{Cvoid}\n\nFunction ptr that unlocks the FFTW planner \nC signature: void (*fftw_unlock_fun)(void *)\n\nfftw_lock_data     :: Ptr{Cvoid}\n\nData to pass to the lock functions (e.g. a mutex) \nC signature: void *fftw_lock_data\n\n\n\n\n\n","category":"type"},{"location":"#Functions","page":"FINUFFT.jl Reference","title":"Functions","text":"","category":"section"},{"location":"#FINUFFT._cufinufft_makeplan-Union{Tuple{dtype}, Tuple{Type{dtype}, Integer, Union{Integer, Array{Int64}}, Integer, Integer, Real}} where dtype","page":"FINUFFT.jl Reference","title":"FINUFFT._cufinufft_makeplan","text":"_cufinufft_makeplan\n\nType-stable internal version of cufinufft_makeplan\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT._finufft_makeplan-Union{Tuple{dtype}, Tuple{Type{dtype}, Integer, Union{Integer, Array{Int64}}, Integer, Integer, Real}} where dtype","page":"FINUFFT.jl Reference","title":"FINUFFT._finufft_makeplan","text":"_finufft_makeplan\n\nType-stable internal version of finufft_makeplan\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.cufinufft_default_opts-Tuple{}","page":"FINUFFT.jl Reference","title":"FINUFFT.cufinufft_default_opts","text":"p = cufinufft_default_opts()\n\nReturn a FINUFFT.cufinufft_opts struct with the default settings.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.cufinufft_destroy!-Union{Tuple{cufinufft_plan{T}}, Tuple{T}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.cufinufft_destroy!","text":"cufinufft_destroy!(plan::cufinufft_plan)\n\nDestroy a cufinufft_plan object, deallocating all memory used.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.cufinufft_exec!-Union{Tuple{T}, Tuple{cufinufft_plan{T}, CuArray{Complex{T}}, CuArray{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.cufinufft_exec!","text":"cufinufft_exec!(plan::cufinufft_plan{T},\n                input::CUDA.CuArray{Complex{T}},\n                output::CUDA.CuArray{Complex{T}}\n                ) \n                where T :: Float32 or Float64\n\nExecute cuFINUFFT transform(s) with preallocated arrays on device.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.cufinufft_exec-Union{Tuple{T}, Tuple{cufinufft_plan{T}, Array{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.cufinufft_exec","text":"cufinufft_exec(plan::cufinufft_plan{T}, \n               input :: Array{Complex{T}} or CUDA.CuArray{Complex{T}}\n               ) -> Array{Complex{T}} or CUDA.CuArray{Complex{T}}\n               where T :: Float32 or Float64\n\nExecute cuFINFFT plan and return output in a newly allocated array.\n\noutput type will match that of input:\n\nIf input is CUDA.CuArray on device, then output is allocated on device.\nIf input is Array on host, then it is copied to device before computation and output is copied to host after computation.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.cufinufft_makeplan-Tuple{Integer, Union{Integer, Array{Int64}}, Integer, Integer, Real}","page":"FINUFFT.jl Reference","title":"FINUFFT.cufinufft_makeplan","text":"cufinufft_makeplan(type::Integer,\n                   n_modes_or_dim::Union{Array{Int64},Integer},\n                   iflag::Integer,\n                   ntrans::Integer,\n                   eps::Real;\n                   dtype=Float64,\n                   kwargs...) -> plan::cufinufft_plan{dtype}\n\nCreate a cufinufft_plan object. See finufft_makeplan for arguments.\n\nkwargs (optional): Options set in FINUFFT.cufinufft_opts.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.cufinufft_setpts!-Union{Tuple{T}, Tuple{cufinufft_plan{T}, Array{T}}, Tuple{cufinufft_plan{T}, Array{T}, Array{T}}, Tuple{cufinufft_plan{T}, Array{T}, Array{T}, Array{T}}, Tuple{cufinufft_plan{T}, Vararg{Array{T}, 4}}, Tuple{cufinufft_plan{T}, Vararg{Array{T}, 5}}, Tuple{cufinufft_plan{T}, Vararg{Array{T}, 6}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.cufinufft_setpts!","text":"cufinufft_setpts!(plan, xj [, yj[, zj[, s[, t[, u]]]]])\n\nInput nonuniform points. See finufft_setpts! for arguments.\n\nPoints can be either CUDA.CuArray's on device or Array's on host. The latter will be automatically copied to device before being passed to cuFINUFFT.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.finufft_default_opts","page":"FINUFFT.jl Reference","title":"FINUFFT.finufft_default_opts","text":"p = finufft_default_opts()\np = finufft_default_opts(dtype=Float32)\n\nReturn a nufft_opts struct with the default FINUFFT settings. Set up the double precision variant by default.\nSee: https://finufft.readthedocs.io/en/latest/usage.html#options\n\n\n\n\n\n","category":"function"},{"location":"#FINUFFT.finufft_destroy!-Union{Tuple{finufft_plan{T}}, Tuple{T}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.finufft_destroy!","text":"status = finufft_destroy!(plan::finufft_plan{T}) where T <: finufftReal\n\nThis destroys a FINUFFT plan object: it deallocates all stored FFTW plans, nonuniform point sorting arrays, kernel Fourier transforms arrays, and any other allocations, and nulls the plan pointer.\n\nAn integer status code is returned, that is 0 if successful. If one attempts to destroy an already-destroyed plan, 1 is returned (see FINUFFT documentation for finufft_destroy).\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.finufft_exec!-Union{Tuple{T}, Tuple{finufft_plan{T}, Union{SubArray{Complex{T}}, Array{Complex{T}}}, Union{SubArray{Complex{T}}, Array{Complex{T}}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.finufft_exec!","text":"finufft_exec!(plan::finufft_plan{T},\n              input::FINUFFT.InputArray{Complex{T}},\n              output::FINUFFT.InputArray{Complex{T}}) where T <: finufftReal\n\nExecute single or many-vector FINUFFT transforms in a plan, with output written to preallocated array. See finufft_exec for arguments.\n\ninput and output must be contiguous arrays.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.finufft_exec-Union{Tuple{T}, Tuple{finufft_plan{T}, Union{SubArray{Complex{T}}, Array{Complex{T}}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.finufft_exec","text":"output::Array{Complex{T}} = finufft_exec(plan::finufft_plan{T},\n                  input::FINUFFT.InputArray{Complex{T}}) where T <: finufftReal\n\nExecute single or many-vector FINUFFT transforms in a plan.\n\noutput = finufft_exec(plan, input)\n\nFor plan a previously created finufft_plan object also containing all needed   nonuniform point coordinates, do a single (or if ntrans>1 in the plan stage, multiple)   NUFFT transform(s), with the strengths or Fourier coefficient inputs vector(s) from   input. The result of the transform(s) is returned as a (possibly multidimensional)   array.\n\nInputs\n\n- `plan`    `finufft_plan` object, already planned and containing nonuniform points.\n- `input`   strengths (types 1 or 3) or Fourier coefficients (type 2) vector, matrix,\n            or array of appropriate size. For type 1 and 3, this is either a length-M\n            vector (where M is the length of `xj`), or an `(M,ntrans)` matrix when\n            `ntrans>1`. For type 2, in 1D this is size `(ms,)`, in 2D size `(ms,mt)`,\n            or in 3D size `(ms,mt,mu)`, or each of these with an extra last dimension\n            `ntrans` if `ntrans>1`.\n            Must be contiguous.\n\nOutput\n\n `output`   vector of output strengths at targets (types 2 or 3), or array of Fourier\n            coefficients (type 1), or, if `ntrans>1`, a stack of such vectors or\n            arrays, of appropriate size.  Specifically, if `ntrans=1`, for type 1, in\n            1D this is size `(ms,)`, in 2D size `(ms,mt)`, or in 3D size `(ms,mt,mu)`;\n            for types 2 and 3 it is a column vector of length `M` (the length of `xj`\n            in type 2), or `nk` (the length of `s` in type 3). If `ntrans>1` it is a\n            stack of such objects, ie, it has an extra last dimension `ntrans`.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.finufft_makeplan-Tuple{Integer, Union{Integer, Array{Int64}}, Integer, Integer, Real}","page":"FINUFFT.jl Reference","title":"FINUFFT.finufft_makeplan","text":"finufft_makeplan(type::Integer,\n                 n_modes_or_dim::Union{Array{Int64},Integer},\n                 iflag::Integer,\n                 ntrans::Integer,\n                 eps::Real;\n                 dtype=Float64,\n                 kwargs...) -> plan::finufft_plan{dtype}\n\nCreates a finufft_plan object for the guru interface to FINUFFT, of  type 1, 2 or 3, and with given numbers of Fourier modes (unless type 3).\n\nInputs\n\ntype            transform type: 1, 2, or 3\nn_modes_or_dim  if type is 1 or 2, the number of Fourier modes in each                 dimension: ms in 1D, [ms mt] in 2D, or [ms mt mu] in 3D.                 Its length thus sets the dimension, which must be 1, 2 or 3.                 If type is 3, in contrast, its value fixes the dimension.\niflag   if >=0, uses + sign in exponential, otherwise - sign.\nntrans          number of transforms to compute simultaneously\neps     relative precision requested (generally between 1e-15 and 1e-1),         real, need not match type of dtype\ndtype           Float32 or Float64, plan for single precision or double precision\nkwargs  (optional): for options, see nufft_opts and https://finufft.readthedocs.io/en/latest/opts.html\n\nReturns\n\nfinufft_plan struct\n\nExamples\n\njulia> p = finufft_makeplan(2,10,+1,1,1e-6);\n\ncreates a plan for a 1D type 2 Float64 transform with 10 Fourier modes and tolerance 1e-6.\n\njulia> p = finufft_makeplan(1,[10 20],+1,1,1e-6);\n\ncreates a plan for a 2D type 1 Float64 transform with 10*20 Fourier modes.\n\njulia> p = finufft_makeplan(3,2,+1,1,1e-4,dtype=Float32,nthreads=4);\n\ncreates a plan for a 2D type 3 Float32 transform with tolerance 1e-4, to use 4 threads.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.finufft_setpts!-Union{Tuple{T}, Tuple{finufft_plan{T}, Union{SubArray{T}, Array{T}}}, Tuple{finufft_plan{T}, Union{SubArray{T}, Array{T}}, Union{SubArray{T}, Array{T}}}, Tuple{finufft_plan{T}, Union{SubArray{T}, Array{T}}, Union{SubArray{T}, Array{T}}, Union{SubArray{T}, Array{T}}}, Tuple{finufft_plan{T}, Vararg{Union{SubArray{T}, Array{T}}, 4}}, Tuple{finufft_plan{T}, Vararg{Union{SubArray{T}, Array{T}}, 5}}, Tuple{finufft_plan{T}, Vararg{Union{SubArray{T}, Array{T}}, 6}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.finufft_setpts!","text":"finufft_setpts!(plan, xj [, yj[, zj[, s[, t[, u]]]]])\n\nInput nonuniform points for general FINUFFT transform(s).\n\nGiven an already-planned finufft_plan, this reads in nonuniform point  coordinate arrays xj (and yj if 2D or 3D, and zj if 3D), and additionally in the type 3 case, nonuniform  frequency target coordinate arrays s (and t if 2D or 3D, and u if 3D). Empty arrays may be passed in the case of  unused dimensions. For all types, sorting is done to internally store a  reindexing of points, and for type 3 the spreading and FFTs are planned.  These nonuniform points may then be used for multiple transforms.\n\nInput\n\nplan   a finufft_plan object for one/many general nonuniform FFTs\nxj     vector of x-coords of all nonuniform points\nyj     empty (if dim<2), or vector of y-coords of all nonuniform points\nzj     empty (if dim<3), or vector of z-coords of all nonuniform points\ns      vector of x-coords of all nonuniform frequency targets\nt      empty (if dim<2), or vector of y-coords of all frequency targets\nu      empty (if dim<3), or vector of z-coords of all frequency targets\n\nVectors must be Array{T} or contiguous SubArray{T} (view), where T is Float32 or Float64.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft1d1!-Union{Tuple{T}, Tuple{Array{T}, Array{Complex{T}}, Integer, Real, Array{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft1d1!","text":"nufft1d1!(xj      :: Array{Float64} or Array{Float32}, \n          cj      :: Array{ComplexF64} or Array{ComplexF32}, \n          iflag   :: Integer, \n          eps     :: Real,\n          fk      :: Array{ComplexF64} or Array{ComplexF32};\n          kwargs...\n        )\n\nCompute type-1 1D complex nonuniform FFT. Output written to fk. See nufft1d1.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft1d1!-Union{Tuple{T}, Tuple{CuArray{T}, CuArray{Complex{T}}, Integer, Real, CuArray{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft1d1!","text":"nufft1d1!(xj      :: CuArray{Float64} or CuArray{Float32},\n          cj      :: CuArray{ComplexF64} or CuArray{ComplexF32},\n          iflag   :: Integer,\n          eps     :: Real,\n          fk      :: CuArray{ComplexF64} or CuArray{ComplexF32};\n          kwargs...\n        )\n\nCUDA version.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft1d1-Union{Tuple{T}, Tuple{Array{T}, Array{Complex{T}}, Integer, Real, Integer}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft1d1","text":"nufft1d1(xj      :: Array{Float64} or Array{Float32}, \n         cj      :: Array{ComplexF64} or Array{ComplexF32}, \n         iflag   :: Integer, \n         eps     :: Real,\n         ms      :: Integer;\n         kwargs...\n        ) -> Array{ComplexF64} or Array{ComplexF32}\n\nCompute type-1 1D complex nonuniform FFT.  This computes, to relative precision eps, via a fast algorithm:\n\n          nj\nf(k1) =  SUM c[j] exp(+/-i k1 x(j))  for -ms/2 <= k1 <= (ms-1)/2\n         j=1\n\nInputs\n\nxj      locations of nonuniform sources on interval [-3pi,3pi), length nj\ncj      length-nj complex vector of source strengths. If length(cj)>nj,         expects a stack of vectors (eg, a nj*ntrans matrix) each of which is         transformed with the same source locations.\niflag   if >=0, uses + sign in exponential, otherwise - sign.\neps     relative precision requested (generally between 1e-15 and 1e-1)\nms      number of Fourier modes computed, may be even or odd;         in either case, mode range is integers lying in [-ms/2, (ms-1)/2]\nkwargs  (optional). See nufft_opts and https://finufft.readthedocs.io/en/latest/opts.html\n\nOutput\n\nsize (ms,) complex vector of Fourier coefficients f, or, if         ntrans>1, matrix of size (ms,ntrans).\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft1d2!-Union{Tuple{T}, Tuple{Array{T}, Array{Complex{T}}, Integer, Real, Array{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft1d2!","text":"nufft1d2!(xj      :: Array{Float64} or Array{Float32}, \n          cj      :: Array{ComplexF64} or Array{ComplexF32}, \n          iflag   :: Integer, \n          eps     :: Real,\n          fk      :: Array{ComplexF64} or Array{ComplexF32};\n          kwargs...\n        )\n\nCompute type-2 1D complex nonuniform FFT. Output written to cj. See nufft1d2.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft1d2!-Union{Tuple{T}, Tuple{CuArray{T}, CuArray{Complex{T}}, Integer, Real, CuArray{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft1d2!","text":"nufft1d2!(xj      :: CuArray{Float64} or CuArray{Float32},\n          cj      :: CuArray{ComplexF64} or CuArray{ComplexF32},\n          iflag   :: Integer,\n          eps     :: Real,\n          fk      :: CuArray{ComplexF64} or CuArray{ComplexF32};\n          kwargs...\n        )\n\nCUDA version.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft1d2-Union{Tuple{T}, Tuple{Array{T}, Integer, Real, Array{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft1d2","text":"nufft1d2(xj      :: Array{Float64} or Array{Float32}, \n         iflag   :: Integer, \n         eps     :: Real,\n         fk      :: Array{ComplexF64} or Array{ComplexF32};\n         kwargs...\n        ) -> Array{ComplexF64}\n\nCompute type-2 1D complex nonuniform FFT.  This computes, to relative precision eps, via a fast algorithm:\n\nc[j] = SUM   f[k1] exp(+/-i k1 x[j])      for j = 1,...,nj\n        k1\n where sum is over -ms/2 <= k1 <= (ms-1)/2.\n\nInput\n\nxj      location of nonuniform targets on interval [-3pi,3pi), length nj\nfk      complex Fourier coefficients. If a vector, length sets ms         (with mode ordering given by opts.modeord). If a matrix, each         column is transformed with the same nonuniform targets.\niflag   if >=0, uses + sign in exponential, otherwise - sign.\neps     relative precision requested (generally between 1e-15 and 1e-1)\nkwargs  (optional). See nufft_opts and https://finufft.readthedocs.io/en/latest/opts.html\n\nOutput\n\ncomplex (nj,) vector c of answers at targets, or,        if ntrans>1, matrix of size (nj,ntrans).\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft1d3!-Union{Tuple{T}, Tuple{Array{T}, Array{Complex{T}}, Integer, Real, Array{T}, Array{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft1d3!","text":"nufft1d3!(xj      :: Array{Float64} or Array{Float32}, \n          cj      :: Array{ComplexF64} or Array{ComplexF32}, \n          iflag   :: Integer, \n          eps     :: Real,\n          sk      :: Array{Float64} or Array{Float32},\n          fk      :: Array{ComplexF64} or Array{ComplexF32};\n          kwargs...\n         )\n\nCompute type-3 1D complex nonuniform FFT. Output written to fk. See nufft1d3.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft1d3!-Union{Tuple{T}, Tuple{CuArray{T}, CuArray{Complex{T}}, Integer, Real, CuArray{T}, CuArray{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft1d3!","text":"nufft1d3!(xj      :: CuArray{Float64} or CuArray{Float32}, \n          cj      :: CuArray{ComplexF64} or CuArray{ComplexF32}, \n          iflag   :: Integer, \n          eps     :: Real,\n          sk      :: CuArray{Float64} or CuArray{Float32},\n          fk      :: CuArray{ComplexF64} or CuArray{ComplexF32};\n          kwargs...\n         )\n\nCUDA version.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft1d3-Union{Tuple{T}, Tuple{Array{T}, Array{Complex{T}}, Integer, Real, Array{T}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft1d3","text":"nufft1d3(xj      :: Array{Float64} or Array{Float32}, \n         cj      :: Array{ComplexF64} or Array{ComplexF32}, \n         iflag   :: Integer, \n         eps     :: Real,\n         sk      :: Array{Float64} or Array{Float32};\n         kwargs...\n        ) -> Array{ComplexF64}\n\nCompute type-3 1D complex nonuniform FFT. This computes, to relative precision eps, via a fast algorithm:\n\n         nj\nf[k]  =  SUM   c[j] exp(+-i s[k] x[j]),      for k = 1, ..., nk\n         j=1\n\nInputs\n\nxj       locations of nonuniform sources on R (real line), length-nj vector.\ncj       length-nj complex vector of source strengths. If length(cj)>nj,           expects a size (nj,ntrans) matrix each column of which is           transformed with the same source and target locations.\niflag    if >=0, uses + sign in exponential, otherwise - sign.\neps      relative precision requested (generally between 1e-15 and 1e-1)\nsk       frequency locations of nonuniform targets on R, length-nk vector.\nkwargs   (optional). See nufft_opts and https://finufft.readthedocs.io/en/latest/opts.html\n\nOutput\n\ncomplex vector f size '(nk,)of values at targets, or, ifntrans>1,          a matrix of size(nk,ntrans)`\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft2d1!-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{Complex{T}}, Integer, Real, Array{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft2d1!","text":"nufft2d1!(xj      :: Array{Float64} or Array{Float32}, \n          yj      :: Array{Float64} or Array{Float32}, \n          cj      :: Array{ComplexF64} or Array{ComplexF32}, \n          iflag   :: Integer, \n          eps     :: Real,\n          fk      :: Array{ComplexF64} or Array{ComplexF32};\n          kwargs...\n        )\n\nCompute type-1 2D complex nonuniform FFT. Output written to fk. See nufft2d1.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft2d1!-Union{Tuple{T}, Tuple{CuArray{T}, CuArray{T}, CuArray{Complex{T}}, Integer, Real, CuArray{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft2d1!","text":"nufft2d1!(xj      :: CuArray{Float64} or CuArray{Float32},\n          yj      :: CuArray{Float64} or CuArray{Float32},\n          cj      :: CuArray{ComplexF64} or CuArray{ComplexF32},\n          iflag   :: Integer,\n          eps     :: Real,\n          fk      :: CuArray{ComplexF64} or CuArray{ComplexF32};\n          kwargs...\n        )\n\nCUDA version.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft2d1-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{Complex{T}}, Integer, Real, Integer, Integer}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft2d1","text":"nufft2d1(xj      :: Array{Float64} or Array{Float32}\n         yj      :: Array{Float64} or Array{Float32}, \n         cj      :: Array{ComplexF64} or Array{ComplexF32}, \n         iflag   :: Integer, \n         eps     :: Real,\n         ms      :: Integer,\n         mt      :: Integer;\n         kwargs...\n        ) -> Array{ComplexF64}\n\nCompute type-1 2D complex nonuniform FFT. This computes, to relative precision eps, via a fast algorithm:\n\n              nj\nf[k1,k2] =   SUM  c[j] exp(+-i (k1 x[j] + k2 y[j]))\n             j=1\n\nfor -ms/2 <= k1 <= (ms-1)/2,  -mt/2 <= k2 <= (mt-1)/2.\n\nInputs\n\nxj,yj   coordinates of nonuniform sources on the square [-3pi,3pi)^2,         each a length-nj vector\ncj      length-nj complex vector of source strengths. If length(cj)>nj,         expects a stack of vectors (eg, a nj*ntrans matrix) each of which is         transformed with the same source locations.\niflag   if >=0, uses + sign in exponential, otherwise - sign.\neps     relative precision requested (generally between 1e-15 and 1e-1)\nms,mt   number of Fourier modes requested in x & y; each may be even or odd.         In either case the mode range is integers lying in [-m/2, (m-1)/2]\nkwargs  (optional), see nufft_opts and https://finufft.readthedocs.io/en/latest/opts.html\n\nOutput\n\nsize (ms,mt) complex matrix of Fourier coefficients f         (ordering given by opts.modeord in each dimension; ms fast, mt slow),         or, if ntrans>1, a array of size (ms,mt,ntrans).\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft2d2!-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{Complex{T}}, Integer, Real, Array{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft2d2!","text":"nufft2d2!(xj      :: Array{Float64} or Array{Float32}, \n          yj      :: Array{Float64} or Array{Float32}, \n          cj      :: Array{ComplexF64} or Array{ComplexF32}, \n          iflag   :: Integer, \n          eps     :: Real,\n          fk      :: Array{ComplexF64} or Array{ComplexF32};\n          kwargs...\n        )\n\nCompute type-2 2D complex nonuniform FFT. Output written to cj. See nufft2d2.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft2d2!-Union{Tuple{T}, Tuple{CuArray{T}, CuArray{T}, CuArray{Complex{T}}, Integer, Real, CuArray{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft2d2!","text":"nufft2d2!(xj      :: CuArray{Float64} or CuArray{Float32},\n          yj      :: CuArray{Float64} or CuArray{Float32},\n          cj      :: CuArray{ComplexF64} or CuArray{ComplexF32},\n          iflag   :: Integer,\n          eps     :: Real,\n          fk      :: CuArray{ComplexF64} or CuArray{ComplexF32};\n          kwargs...\n        )\n\nCUDA version.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft2d2-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Integer, Real, Array{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft2d2","text":"nufft2d2(xj      :: Array{Float64} or Array{Float32}, \n         yj      :: Array{Float64} or Array{Float32}, \n         iflag   :: Integer, \n         eps     :: Real,\n         fk      :: Array{ComplexF64} or Array{ComplexF32};\n         kwargs...\n        ) -> Array{ComplexF64}\n\nCompute type-2 2D complex nonuniform FFT.  This computes, to relative precision eps, via a fast algorithm:\n\nc[j] =  SUM   f[k1,k2] exp(+/-i (k1 x[j] + k2 y[j]))  for j = 1,..,nj\n       k1,k2\n where sum is over -ms/2 <= k1 <= (ms-1)/2, -mt/2 <= k2 <= (mt-1)/2,\n\nInputs\n\nxj,yj   coordinates of nonuniform targets on the square [-3pi,3pi)^2,        each a vector of length nj\nfk      complex Fourier coefficient matrix, whose size determines (ms,mt).        (Mode ordering given by opts.modeord, in each dimension.)        If a 3D array, 3rd dimension sets ntrans, and each of ntrans        matrices is transformed with the same nonuniform targets.\niflag   if >=0, uses + sign in exponential, otherwise - sign.\neps     relative precision requested (generally between 1e-15 and 1e-1)\nkwargs  (optional). See nufft_opts and https://finufft.readthedocs.io/en/latest/opts.html\n\nOutput\n\ncomplex size (nj,) vector c of answers at targets, or,        if ntrans>1, matrix of size (nj,ntrans).\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft2d3!-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{Complex{T}}, Integer, Real, Array{T}, Array{T}, Array{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft2d3!","text":"nufft2d3!(xj      :: Array{Float64} or Array{Float32}, \n          yj      :: Array{Float64} or Array{Float32},\n          cj      :: Array{ComplexF64} or Array{ComplexF32}, \n          iflag   :: Integer, \n          eps     :: Real,\n          sk      :: Array{Float64} or Array{Float32},\n          tk      :: Array{Float64} or Array{Float32},\n          fk      :: Array{ComplexF64} or Array{ComplexF32};\n          kwargs...\n         )\n\nCompute type-3 2D complex nonuniform FFT. Output written to 'fk'. See nufft2d3.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft2d3!-Union{Tuple{T}, Tuple{CuArray{T}, CuArray{T}, CuArray{Complex{T}}, Integer, Real, CuArray{T}, CuArray{T}, CuArray{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft2d3!","text":"nufft2d3!(xj      :: CuArray{Float64} or CuArray{Float32}, \n          yj      :: CuArray{Float64} or CuArray{Float32},\n          cj      :: CuArray{ComplexF64} or CuArray{ComplexF32}, \n          iflag   :: Integer, \n          eps     :: Real,\n          sk      :: CuArray{Float64} or CuArray{Float32},\n          tk      :: CuArray{Float64} or CuArray{Float32},\n          fk      :: CuArray{ComplexF64} or CuArray{ComplexF32};\n          kwargs...\n         )\n\nCUDA version.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft2d3-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{Complex{T}}, Integer, Real, Array{T}, Array{T}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft2d3","text":"nufft2d3(xj      :: Array{Float64} or Array{Float32}, \n         yj      :: Array{Float64} or Array{Float32},\n         cj      :: Array{ComplexF64} or Array{ComplexF32}, \n         iflag   :: Integer, \n         eps     :: Real,\n         sk      :: Array{Float64} or Array{Float32},\n         tk      :: Array{Float64} or Array{Float32};\n         kwargs...\n        ) -> Array{ComplexF64}\n\nCompute type-3 2D complex nonuniform FFT. This computes, to relative precision eps, via a fast algorithm:\n\n         nj\nf[k]  =  SUM   c[j] exp(+-i (s[k] x[j] + t[k] y[j])),  for k = 1, ..., nk\n         j=1\n\nInputs\n\nxj,yj    coordinates of nonuniform sources in R^2, each a length-nj vector.\ncj    complex vector (nj,) of source strengths. If length(cj)>nj,          expects a (nj,ntrans) matrix, each column of which is          transformed with the same source and target locations.\niflag    if >=0, uses + sign in exponential, otherwise - sign.\neps      relative precision requested (generally between 1e-15 and 1e-1)\nsk,tk    frequency coordinates of nonuniform targets in R^2,          each a length-nk vector.\nkwargs   (optional). See nufft_opts and https://finufft.readthedocs.io/en/latest/opts.html\n\nOutput\n\ncomplex vector size (nk,) of values at targets, or, if ntrans>1,          a matrix of size (nk,ntrans)\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft3d1!-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{T}, Array{Complex{T}}, Integer, Real, Array{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft3d1!","text":"nufft3d1!(xj      :: Array{Float64} or Array{Float32}, \n          yj      :: Array{Float64} or Array{Float32}, \n          zj      :: Array{Float64} or Array{Float32}, \n          cj      :: Array{ComplexF64} or Array{ComplexF32}, \n          iflag   :: Integer, \n          eps     :: Real,\n          fk      :: Array{ComplexF64} or Array{ComplexF32};\n          kwargs...\n        )\n\nCompute type-1 3D complex nonuniform FFT. Output written to fk. See nufft3d1.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft3d1!-Union{Tuple{T}, Tuple{CuArray{T}, CuArray{T}, CuArray{T}, CuArray{Complex{T}}, Integer, Real, CuArray{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft3d1!","text":"nufft3d1!(xj      :: CuArray{Float64} or CuArray{Float32},\n          yj      :: CuArray{Float64} or CuArray{Float32},\n          zj      :: CuArray{Float64} or CuArray{Float32},\n          cj      :: CuArray{ComplexF64} or CuArray{ComplexF32},\n          iflag   :: Integer,\n          eps     :: Real,\n          fk      :: CuArray{ComplexF64} or CuArray{ComplexF32};\n          kwargs...\n        )\n\nCUDA version.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft3d1-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{T}, Array{Complex{T}}, Integer, Real, Integer, Integer, Integer}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft3d1","text":"nufft3d1(xj      :: Array{Float64} or Array{Float32}, \n         yj      :: Array{Float64} or Array{Float32}, \n         zj      :: Array{Float64} or Array{Float32}, \n         cj      :: Array{ComplexF64} or Array{ComplexF32}, \n         iflag   :: Integer, \n         eps     :: Real,\n         ms      :: Integer,\n         mt      :: Integer,\n         mu      :: Integer;\n         kwargs...\n        ) -> Array{ComplexF64}\n\nCompute type-1 3D complex nonuniform FFT. This computes, to relative precision eps, via a fast algorithm:\n\n                  nj\nf[k1,k2,k3] =    SUM  c[j] exp(+-i (k1 x[j] + k2 y[j] + k3 z[j]))\n                 j=1\n\nfor -ms/2 <= k1 <= (ms-1)/2,  -mt/2 <= k2 <= (mt-1)/2,\n    -mu/2 <= k3 <= (mu-1)/2.\n\nInputs\n\nxj,yj,zj coordinates of nonuniform sources on the cube [-3pi,3pi)^3,           each a length-nj vector\ncj       length-nj complex vector of source strengths. If length(cj)>nj,           expects a stack of vectors (eg, a nj*ntrans matrix) each of which is           transformed with the same source locations.\niflag    if >=0, uses + sign in exponential, otherwise - sign.\neps      relative precision requested (generally between 1e-15 and 1e-1)\nms,mt,mu number of Fourier modes requested in x,y and z; each may be           even or odd.           In either case the mode range is integers lying in [-m/2, (m-1)/2]\nkwargs  (optional). See nufft_opts and https://finufft.readthedocs.io/en/latest/opts.html\n\nOutput\n\nsize (ms,mt,mu) complex array of Fourier coefficients f         (ordering given by opts.modeord in each dimension; ms fastest, mu         slowest), or, if ntrans>1, a 4D array of size (ms,mt,mu,ntrans).\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft3d2!-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{T}, Array{Complex{T}}, Integer, Real, Array{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft3d2!","text":"nufft3d2!(xj      :: Array{Float64} or Array{Float32}, \n          yj      :: Array{Float64} or Array{Float32}, \n          zj      :: Array{Float64} or Array{Float32}, \n          cj      :: Array{ComplexF64} or Array{ComplexF32}, \n          iflag   :: Integer, \n          eps     :: Real,\n          fk      :: Array{ComplexF64} or Array{ComplexF32};\n          kwargs...\n        )\n\nCompute type-2 3D complex nonuniform FFT. Output written to cj. See nufft3d2.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft3d2!-Union{Tuple{T}, Tuple{CuArray{T}, CuArray{T}, CuArray{T}, CuArray{Complex{T}}, Integer, Real, CuArray{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft3d2!","text":"nufft3d2!(xj      :: CuArray{Float64} or CuArray{Float32},\n          yj      :: CuArray{Float64} or CuArray{Float32},\n          zj      :: CuArray{Float64} or CuArray{Float32},\n          cj      :: CuArray{ComplexF64} or CuArray{ComplexF32},\n          iflag   :: Integer,\n          eps     :: Real,\n          fk      :: CuArray{ComplexF64} or CuArray{ComplexF32};\n          kwargs...\n        )\n\nCUDA version.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft3d2-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{T}, Integer, Real, Array{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft3d2","text":"nufft3d2(xj      :: Array{Float64} or Array{Float32}, \n         yj      :: Array{Float64} or Array{Float32}, \n         zj      :: Array{Float64} or Array{Float32}, \n         iflag   :: Integer, \n         eps     :: Real,\n         fk      :: Array{ComplexF64} or Array{ComplexF32};\n         kwargs...\n        ) -> Array{ComplexF64}\n\nCompute type-2 3D complex nonuniform FFT.  This computes, to relative precision eps, via a fast algorithm:\n\nc[j] =   SUM   f[k1,k2,k3] exp(+/-i (k1 x[j] + k2 y[j] + k3 z[j]))\n       k1,k2,k3\n                       for j = 1,..,nj\n where sum is over -ms/2 <= k1 <= (ms-1)/2, -mt/2 <= k2 <= (mt-1)/2,\n                  -mu/2 <= k3 <= (mu-1)/2.\n\nInputs\n\nxj,yj,zj coordinates of nonuniform targets on the cube [-3pi,3pi)^3,          each a vector of length nj\nfk       complex Fourier coefficient array, whose size sets (ms,mt,mu).          (Mode ordering given by opts.modeord, in each dimension.)          If a 4D array, 4th dimension sets ntrans, and each of ntrans          3D arrays is transformed with the same nonuniform targets.\niflag    if >=0, uses + sign in exponential, otherwise - sign.\neps      relative precision requested (generally between 1e-15 and 1e-1)\nkwargs   (optional). See nufft_opts and https://finufft.readthedocs.io/en/latest/opts.html\n\nOutput\n\ncomplex vector c of size (nj,) giving answers at targets, or,         if ntrans>1, matrix of size (nj,ntrans).\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft3d3!-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{T}, Array{Complex{T}}, Integer, Real, Array{T}, Array{T}, Array{T}, Array{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft3d3!","text":"nufft3d3!(xj      :: Array{Float64} or Array{Float32}, \n          yj      :: Array{Float64} or Array{Float32},\n          zj      :: Array{Float64} or Array{Float32},\n          cj      :: Array{ComplexF64} or Array{ComplexF32}, \n          iflag   :: Integer, \n          eps     :: Real,\n          sk      :: Array{Float64} or Array{Float32},\n          tk      :: Array{Float64} or Array{Float32},\n          uk      :: Array{Float64} or Array{Float32},\n          fk      :: Array{ComplexF64} or Array{ComplexF32};\n          kwargs...\n         )\n\nCompute type-3 3D complex nonuniform FFT. Output written to fk. See nufft3d3.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft3d3!-Union{Tuple{T}, Tuple{CuArray{T}, CuArray{T}, CuArray{T}, CuArray{Complex{T}}, Integer, Real, CuArray{T}, CuArray{T}, CuArray{T}, CuArray{Complex{T}}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft3d3!","text":"nufft3d3!(xj      :: CuArray{Float64} or CuArray{Float32}, \n          yj      :: CuArray{Float64} or CuArray{Float32},\n          zj      :: CuArray{Float64} or CuArray{Float32},\n          cj      :: CuArray{ComplexF64} or CuArray{ComplexF32}, \n          iflag   :: Integer, \n          eps     :: Real,\n          sk      :: CuArray{Float64} or CuArray{Float32},\n          tk      :: CuArray{Float64} or CuArray{Float32},\n          uk      :: CuArray{Float64} or CuArray{Float32},\n          fk      :: CuArray{ComplexF64} or CuArray{ComplexF32};\n          kwargs...\n         )\n\nCUDA version.\n\n\n\n\n\n","category":"method"},{"location":"#FINUFFT.nufft3d3-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{T}, Array{Complex{T}}, Integer, Real, Array{T}, Array{T}, Array{T}}} where T<:Union{Float32, Float64}","page":"FINUFFT.jl Reference","title":"FINUFFT.nufft3d3","text":"nufft3d3(xj      :: Array{Float64} or Array{Float32}, \n         yj      :: Array{Float64} or Array{Float32},\n         zj      :: Array{Float64} or Array{Float32},\n         cj      :: Array{ComplexF64} or Array{ComplexF32}, \n         iflag   :: Integer, \n         eps     :: Real,\n         sk      :: Array{Float64} or Array{Float32},\n         tk      :: Array{Float64} or Array{Float32},\n         uk      :: Array{Float64} or Array{Float32};\n         kwargs...\n        ) -> Array{ComplexF64}\n\nCompute type-3 3D complex nonuniform FFT. This computes, to relative precision eps, via a fast algorithm:\n\n         nj\nf[k]  =  SUM   c[j] exp(+-i (s[k] x[j] + t[k] y[j] + u[k] z[j])),\n         j=1\n                         for k = 1, ..., nk\n\nInputs\n\nxj,yj,zj coordinates of nonuniform sources in R^3, each a length-nj vector.\ncj     complex (nj,) vector of source strengths. If length(cj)>nj,          expects a '(nj,ntrans)' matrix, each column of which is          transformed with the same source and target locations.\niflag    if >=0, uses + sign in exponential, otherwise - sign.\neps      relative precision requested (generally between 1e-15 and 1e-1)\nsk,tk,uk` frequency coordinates of nonuniform targets in R^3,          each a length-nk vector.\nkwargs   (optional). See nufft_opts and https://finufft.readthedocs.io/en/latest/opts.html\n\nOutput\n\nsize (nk,) complex vector f values at targets, or, if ntrans>1,          a matrix of size (nk,ntrans)\n\n\n\n\n\n","category":"method"}]
}
