<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>FINUFFT.jl Reference · FINUFFT.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FINUFFT.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>FINUFFT.jl Reference</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li class="toplevel"><a class="tocitem" href="#Types"><span>Types</span></a></li><li class="toplevel"><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>FINUFFT.jl Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>FINUFFT.jl Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ludvigak/FINUFFT.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="FINUFFT.jl-Reference"><a class="docs-heading-anchor" href="#FINUFFT.jl-Reference">FINUFFT.jl Reference</a><a id="FINUFFT.jl-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#FINUFFT.jl-Reference" title="Permalink"></a></h1><p>For installation and basic usage, see the README at <a href="https://github.com/ludvigak/FINUFFT.jl">https://github.com/ludvigak/FINUFFT.jl</a></p><p>For documentation of the library functions that are being called, see the FINUFFT documentation at <a href="https://finufft.readthedocs.io">https://finufft.readthedocs.io</a></p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#FINUFFT.nufft_opts"><code>FINUFFT.nufft_opts</code></a></li><li><a href="#FINUFFT.finufft_default_opts"><code>FINUFFT.finufft_default_opts</code></a></li><li><a href="#FINUFFT.finufft_destroy-Union{Tuple{finufft_plan{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.finufft_destroy</code></a></li><li><a href="#FINUFFT.finufft_exec-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.finufft_exec</code></a></li><li><a href="#FINUFFT.finufft_exec!-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{Complex{T}, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.finufft_exec!</code></a></li><li><a href="#FINUFFT.finufft_makeplan-Tuple{Integer, Union{Integer, Array{Int64, N} where N}, Integer, Integer, Real}"><code>FINUFFT.finufft_makeplan</code></a></li><li><a href="#FINUFFT.finufft_setpts-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.finufft_setpts</code></a></li><li><a href="#FINUFFT.nufft1d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d1</code></a></li><li><a href="#FINUFFT.nufft1d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d1!</code></a></li><li><a href="#FINUFFT.nufft1d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d2</code></a></li><li><a href="#FINUFFT.nufft1d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d2!</code></a></li><li><a href="#FINUFFT.nufft1d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d3</code></a></li><li><a href="#FINUFFT.nufft1d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d3!</code></a></li><li><a href="#FINUFFT.nufft2d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer, Integer}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d1</code></a></li><li><a href="#FINUFFT.nufft2d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d1!</code></a></li><li><a href="#FINUFFT.nufft2d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d2</code></a></li><li><a href="#FINUFFT.nufft2d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d2!</code></a></li><li><a href="#FINUFFT.nufft2d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d3</code></a></li><li><a href="#FINUFFT.nufft2d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d3!</code></a></li><li><a href="#FINUFFT.nufft3d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer, Integer, Integer}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d1</code></a></li><li><a href="#FINUFFT.nufft3d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d1!</code></a></li><li><a href="#FINUFFT.nufft3d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d2</code></a></li><li><a href="#FINUFFT.nufft3d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d2!</code></a></li><li><a href="#FINUFFT.nufft3d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d3</code></a></li><li><a href="#FINUFFT.nufft3d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d3!</code></a></li></ul><h1 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft_opts" href="#FINUFFT.nufft_opts"><code>FINUFFT.nufft_opts</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct nufft_opts    
    modeord            :: Cint
    chkbnds            :: Cint
    debug              :: Cint
    spread_debug       :: Cint
    showwarn           :: Cint
    nthreads           :: Cint
    fftw               :: Cint
    spread_sort        :: Cint
    spread_kerevalmeth :: Cint
    spread_kerpad      :: Cint
    upsampfac          :: Cdouble
    spread_thread      :: Cint
    maxbatchsize       :: Cint
    spread_nthr_atomic :: Cint
    spread_max_sp_size :: Cint
end</code></pre><p>Options struct passed to the FINUFFT library.</p><p><strong>Fields</strong></p><p>Summary only; see FINUFFT documentation for full descriptions.</p><pre><code class="language-none">modeord :: Cint</code></pre><p>0: CMCL-style increasing mode ordering (neg to pos), or<br/>1: FFT-style mode ordering (affects type-1,2 only)</p><pre><code class="language-none">chkbnds :: Cint</code></pre><p>0: don&#39;t check if input NU pts in [-3pi,3pi], 1: do</p><pre><code class="language-none">debug :: Cint</code></pre><p>0: silent, 1: text basic timing output</p><pre><code class="language-none">spread_debug :: Cint</code></pre><p>passed to spread_opts, 0 (no text) 1 (some) or 2 (lots)</p><pre><code class="language-none">showwarn :: Cint</code></pre><p>Whether to print warnings to stderr. 0: silent, 1: print warnings</p><pre><code class="language-none">nthreads :: Cint</code></pre><p>How many threads FINUFFT should use, or 0 (use max available in OMP)</p><pre><code class="language-none">fftw :: Cint</code></pre><p>0:<code>FFTW_ESTIMATE</code>, or 1:<code>FFTW_MEASURE</code> (slow plan but faster FFTs)</p><pre><code class="language-none">spread_sort :: Cint</code></pre><p>passed to spread_opts, 0 (don&#39;t sort) 1 (do) or 2 (heuristic)</p><pre><code class="language-none">spread_kerevalmeth :: Cint</code></pre><p>passed to spread_opts, 0: exp(sqrt()), 1: Horner ppval (faster)</p><pre><code class="language-none">spread_kerpad :: Cint</code></pre><p>passed to spread_opts, 0: don&#39;t pad to mult of 4, 1: do</p><pre><code class="language-none">upsampfac :: Cdouble</code></pre><p>upsampling ratio sigma: 2.0 (standard), or 1.25 (small FFT), or<br/>0.0 (auto).</p><pre><code class="language-none">spread_thread :: Cint</code></pre><p>(for ntrans&gt;1 only)<br/>0: auto choice,<br/>1: sequential multithreaded,<br/>2: parallel singlethreaded spread.</p><pre><code class="language-none">maxbatchsize :: Cint</code></pre><p>(for ntrans&gt;1 only). max blocking size for vectorized, 0 for auto-set</p><pre><code class="language-none">spread_nthr_atomic :: Cint</code></pre><p>if &gt;=0, threads above which spreader OMP critical goes atomic</p><pre><code class="language-none">spread_max_sp_size :: Cint</code></pre><p>if &gt;0, overrides spreader (dir=1 only) max subproblem size</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/FINUFFT.jl#L35-L109">source</a></section></article><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.finufft_default_opts" href="#FINUFFT.finufft_default_opts"><code>FINUFFT.finufft_default_opts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">finufft_default_opts()</code></pre><p>Return a <a href="#FINUFFT.nufft_opts"><code>nufft_opts</code></a> struct with the default FINUFFT settings. Set up the double precision variant by default.<br/>See: <a href="https://finufft.readthedocs.io/en/latest/usage.html#options">https://finufft.readthedocs.io/en/latest/usage.html#options</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/FINUFFT.jl#L134-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.finufft_destroy-Union{Tuple{finufft_plan{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.finufft_destroy-Union{Tuple{finufft_plan{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.finufft_destroy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>To deallocate (delete) a nonuniform FFT plan, use delete(plan) This deallocates all stored FFTW plans, nonuniform point sorting arrays, kernel Fourier transforms arrays, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/guru.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.finufft_exec!-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{Complex{T}, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.finufft_exec!-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{Complex{T}, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.finufft_exec!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Execute single or many-vector FINUFFT transforms in a plan. Output stored in output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/guru.jl#L256-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.finufft_exec-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.finufft_exec-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.finufft_exec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>execute single or many-vector FINUFFT transforms in a plan.</p><p>output = finufft_exec(plan, input)</p><p>For plan a previously created finufft<em>plan object also containing all   needed nonuniform point coordinates, do a single (or if ntrans&gt;1 in the   plan stage, multiple) NUFFT transform(s), with the strengths or Fourier   coefficient inputs vector(s) from data</em>in. The result of the transform(s)   is returned as a (possibly multidimensional) array.</p><p>Inputs:      plan     finufft_plan struct      input    strengths (types 1 or 3) or Fourier coefficients (type 2)               vector, matrix, or array of appropriate size. For type 1 and 3,               this is either a length-M vector (where M is the length of xj),               or an (M,ntrans) matrix when ntrans&gt;1. For type 2, in 1D this is               length-ms, in 2D size (ms,mt), or in 3D size (ms,mt,mu), or               each of these with an extra last dimension ntrans if ntrans&gt;1.  Outputs:      output   vector of output strengths at targets (types 2 or 3), or array               of Fourier coefficients (type 1), or, if ntrans&gt;1, a stack of               such vectors or arrays, of appropriate size.               Specifically, if ntrans=1, for type 1, in 1D               this is a length-ms column vector, in 2D a matrix of size               (ms,mt), or in 3D an array of size (ms,mt,mu); for types 2 and 3               it is a column vector of length M (the length of xj in type 2),               or nk (the length of s in type 3). If ntrans&gt;1 its is a stack               of such objects, ie, it has an extra last dimension ntrans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/guru.jl#L168-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.finufft_makeplan-Tuple{Integer, Union{Integer, Array{Int64, N} where N}, Integer, Integer, Real}" href="#FINUFFT.finufft_makeplan-Tuple{Integer, Union{Integer, Array{Int64, N} where N}, Integer, Integer, Real}"><code>FINUFFT.finufft_makeplan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates a finufft_makeplan struct in the guru interface to FINUFFT, of  type 1, 2 or 3, and with given numbers of Fourier modes (unless type 3).</p><p>Inputs:     type            transform type: 1, 2, or 3     n<em>modes</em>or<em>dim  if type is 1 or 2, the number of Fourier modes in each                     dimension: [ms] in 1D, [ms mt] in 2D, or [ms mt mu] in 3D.                     Its length sets the dimension, which must be 1, 2 or 3.                     If type is 3, in contrast, its <em>value</em> fixes the dimension     iflag   if &gt;=0, uses + sign in exponential, otherwise - sign.     eps     relative precision requested (generally between 1e-15 and 1e-1),             real, need not match type of dtype     ntrans          number of transforms to compute simultaneously     dtype           Float32 or Float64, plan for single precision or double precision     kwargs  (optional), for more options, see https://finufft.readthedocs.io/en/latest/opts.html Outputs:     plan            finufft</em>plan struct</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/guru.jl#L16-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.finufft_setpts-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.finufft_setpts-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.finufft_setpts</code></a> — <span class="docstring-category">Method</span></header><section><div><p>process nonuniform points for general FINUFFT transform(s).</p><p>With a finufft_plan struct, setpts brings in nonuniform point  coordinates (xj,yj,zj), and additionally in the type 3 case, nonuniform  frequency target points (s,t,u). Empty arrays may be passed in the case of  unused dimensions. For all types, sorting is done to internally store a  reindexing of points, and for type 3 the spreading and FFTs are planned.  The nonuniform points may be used for multiple transforms.</p><p>Inputs:     plan   the finufft_plan guru plan struct for one/many general nonuniform FFTs     xj     vector of x-coords of all nonuniform points     yj     empty (if dim&lt;2), or vector of y-coords of all nonuniform points     zj     empty (if dim&lt;3), or vector of z-coords of all nonuniform points     s      vector of x-coords of all nonuniform frequency targets     t      empty (if dim&lt;2), or vector of y-coords of all frequency targets     u      empty (if dim&lt;3), or vector of z-coords of all frequency targets</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/guru.jl#L99-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft1d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft1d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d1!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft1d1!(xj      :: Array{Float64} or Array{Float32}, 
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
        )</code></pre><p>Compute type-1 1D complex nonuniform FFT. Output stored in fk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L451-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft1d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft1d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft1d1(xj      :: Array{Float64} or Array{Float32}, 
         cj      :: Array{ComplexF64} or Array{ComplexF32}, 
         iflag   :: Integer, 
         eps     :: Real,
         ms      :: Integer;
         kwargs...
        ) -&gt; Array{ComplexF64} or Array{ComplexF32}</code></pre><p>Compute type-1 1D complex nonuniform FFT.  This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">          nj
f(k1) =  SUM c[j] exp(+/-i k1 x(j))  for -ms/2 &lt;= k1 &lt;= (ms-1)/2
         j=1</code></pre><p>Inputs:     xj      locations of nonuniform sources on interval [-3pi,3pi), length nj     cj      length-nj complex vector of source strengths. If length(cj)&gt;nj,             expects a stack of vectors (eg, a nj*ntrans matrix) each of which is             transformed with the same source locations.     iflag   if &gt;=0, uses + sign in exponential, otherwise - sign.     eps     relative precision requested (generally between 1e-15 and 1e-1)     ms      number of Fourier modes computed, may be even or odd;             in either case, mode range is integers lying in [-ms/2, (ms-1)/2]     kwargs  (optional), for more options, see https://finufft.readthedocs.io/en/latest/opts.html   Outputs:     fk      size-ms complex column vector of Fourier coefficients, or, if             ntrans&gt;1, a matrix of size (ms,ntrans).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L5-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft1d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft1d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft1d2!(xj      :: Array{Float64} or Array{Float32}, 
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
        )</code></pre><p>Compute type-2 1D complex nonuniform FFT. Output stored in cj.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L481-L491">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft1d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft1d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft1d2(xj      :: Array{Float64} or Array{Float32}, 
         iflag   :: Integer, 
         eps     :: Real,
         fk      :: Array{ComplexF64} or Array{ComplexF32};
         kwargs...
        ) -&gt; Array{ComplexF64}</code></pre><p>Compute type-2 1D complex nonuniform FFT.  This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">c[j] = SUM   f[k1] exp(+/-i k1 x[j])      for j = 1,...,nj
        k1
 where sum is over -ms/2 &lt;= k1 &lt;= (ms-1)/2.</code></pre><p>Inputs:     xj      location of nonuniform targets on interval [-3pi,3pi), length nj     fk      complex Fourier coefficients. If a vector, length sets ms             (with mode ordering given by opts.modeord). If a matrix, each             of ntrans columns is transformed with the same nonuniform targets.     iflag   if &gt;=0, uses + sign in exponential, otherwise - sign.     eps     relative precision requested (generally between 1e-15 and 1e-1)     kwargs  (optional), for more options, see https://finufft.readthedocs.io/en/latest/opts.html   Outputs:     cj     complex column vector of nj answers at targets, or,            if ntrans&gt;1, matrix of size (nj,ntrans).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L164-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft1d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft1d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d3!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft1d3!(xj      :: Array{Float64} or Array{Float32}, 
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          sk      :: Array{Float64} or Array{Float32},
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
         )</code></pre><p>Compute type-3 1D complex nonuniform FFT. Output stored in fk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L510-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft1d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft1d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft1d3(xj      :: Array{Float64} or Array{Float32}, 
         cj      :: Array{ComplexF64} or Array{ComplexF32}, 
         iflag   :: Integer, 
         eps     :: Real,
         sk      :: Array{Float64} or Array{Float32};
         kwargs...
        ) -&gt; Array{ComplexF64}</code></pre><p>Compute type-3 1D complex nonuniform FFT. This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">         nj
f[k]  =  SUM   c[j] exp(+-i s[k] x[j]),      for k = 1, ..., nk
         j=1</code></pre><p>Inputs:     xj       locations of nonuniform sources on R (real line), length-nj vector.     cj       length-nj complex vector of source strengths. If length(cj)&gt;nj,              expects a stack of vectors (eg, a nj*ntrans matrix) each of which is              transformed with the same source and target locations.     iflag    if &gt;=0, uses + sign in exponential, otherwise - sign.     eps      relative precision requested (generally between 1e-15 and 1e-1)     sk       frequency locations of nonuniform targets on R, length-nk vector.     kwargs   (optional), for more options, see https://finufft.readthedocs.io/en/latest/opts.html   Outputs:     fk       length-nk complex vector of values at targets, or, if ntrans&gt;1,              a matrix of size (nk,ntrans)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L302-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft2d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft2d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d1!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft2d1!(xj      :: Array{Float64} or Array{Float32}, 
          yj      :: Array{Float64} or Array{Float32}, 
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
        )</code></pre><p>Compute type-1 2D complex nonuniform FFT. Output stored in fk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L543-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft2d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer, Integer}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft2d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer, Integer}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft2d1(xj      :: Array{Float64} or Array{Float32}
         yj      :: Array{Float64} or Array{Float32}, 
         cj      :: Array{ComplexF64} or Array{ComplexF32}, 
         iflag   :: Integer, 
         eps     :: Real,
         ms      :: Integer,
         mt      :: Integer;
         kwargs...
        ) -&gt; Array{ComplexF64}</code></pre><p>Compute type-1 2D complex nonuniform FFT. This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">              nj
f[k1,k2] =   SUM  c[j] exp(+-i (k1 x[j] + k2 y[j]))
             j=1

for -ms/2 &lt;= k1 &lt;= (ms-1)/2,  -mt/2 &lt;= k2 &lt;= (mt-1)/2.</code></pre><p>Inputs:     xj,yj   coordinates of nonuniform sources on the square [-3pi,3pi)^2,             each a length-nj vector     cj      length-nj complex vector of source strengths. If length(cj)&gt;nj,             expects a stack of vectors (eg, a nj*ntrans matrix) each of which is             transformed with the same source locations.     iflag   if &gt;=0, uses + sign in exponential, otherwise - sign.     eps     relative precision requested (generally between 1e-15 and 1e-1)     ms,mt   number of Fourier modes requested in x &amp; y; each may be even or odd.             In either case the mode range is integers lying in [-m/2, (m-1)/2]     kwargs  (optional), for more options, see https://finufft.readthedocs.io/en/latest/opts.html   Outputs:     fk      size (ms,mt) complex matrix of Fourier coefficients             (ordering given by opts.modeord in each dimension; ms fast, mt slow),             or, if ntrans&gt;1, a 3D array of size (ms,mt,ntrans).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L49-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft2d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft2d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft2d2!(xj      :: Array{Float64} or Array{Float32}, 
          yj      :: Array{Float64} or Array{Float32}, 
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
        )</code></pre><p>Compute type-2 2D complex nonuniform FFT. Output stored in cj.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L576-L587">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft2d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft2d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft2d2(xj      :: Array{Float64} or Array{Float32}, 
         yj      :: Array{Float64} or Array{Float32}, 
         iflag   :: Integer, 
         eps     :: Real,
         fk      :: Array{ComplexF64} or Array{ComplexF32};
         kwargs...
        ) -&gt; Array{ComplexF64}</code></pre><p>Compute type-2 2D complex nonuniform FFT.  This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">c[j] =  SUM   f[k1,k2] exp(+/-i (k1 x[j] + k2 y[j]))  for j = 1,..,nj
       k1,k2
 where sum is over -ms/2 &lt;= k1 &lt;= (ms-1)/2, -mt/2 &lt;= k2 &lt;= (mt-1)/2,</code></pre><p>Inputs:     xj,yj   coordinates of nonuniform targets on the square [-3pi,3pi)^2,             each a vector of length nj     fk      complex Fourier coefficient matrix, whose size determines (ms,mt).             (Mode ordering given by opts.modeord, in each dimension.)             If a 3D array, 3rd dimension sets ntrans, and each of ntrans             matrices is transformed with the same nonuniform targets.     iflag   if &gt;=0, uses + sign in exponential, otherwise - sign.     eps     relative precision requested (generally between 1e-15 and 1e-1)     kwargs  (optional), for more options, see https://finufft.readthedocs.io/en/latest/opts.html   Outputs:     cj      complex column vector of nj answers at targets, or,             if ntrans&gt;1, matrix of size (nj,ntrans).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L205-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft2d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft2d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d3!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft2d3!(xj      :: Array{Float64} or Array{Float32}, 
          yj      :: Array{Float64} or Array{Float32},
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          sk      :: Array{Float64} or Array{Float32},
          tk      :: Array{Float64} or Array{Float32},
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
         )</code></pre><p>Compute type-3 2D complex nonuniform FFT. Output stored in fk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L606-L619">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft2d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft2d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft2d3(xj      :: Array{Float64} or Array{Float32}, 
         yj      :: Array{Float64} or Array{Float32},
         cj      :: Array{ComplexF64} or Array{ComplexF32}, 
         iflag   :: Integer, 
         eps     :: Real,
         sk      :: Array{Float64} or Array{Float32},
         tk      :: Array{Float64} or Array{Float32};
         kwargs...
        ) -&gt; Array{ComplexF64}</code></pre><p>Compute type-3 2D complex nonuniform FFT. This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">         nj
f[k]  =  SUM   c[j] exp(+-i (s[k] x[j] + t[k] y[j])),  for k = 1, ..., nk
         j=1</code></pre><p>Inputs:     xj,yj    coordinates of nonuniform sources in R^2, each a length-nj vector.     cj       length-nj complex vector of source strengths. If length(cj)&gt;nj,              expects a stack of vectors (eg, a nj*ntrans matrix) each of which is              transformed with the same source and target locations.     iflag    if &gt;=0, uses + sign in exponential, otherwise - sign.     eps      relative precision requested (generally between 1e-15 and 1e-1)     sk,tk    frequency coordinates of nonuniform targets in R^2,              each a length-nk vector.     kwargs   (optional), for more options, see https://finufft.readthedocs.io/en/latest/opts.html   Outputs:     fk       length-nk complex vector of values at targets, or, if ntrans&gt;1,              a matrix of size (nk,ntrans)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L345-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft3d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft3d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d1!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft3d1!(xj      :: Array{Float64} or Array{Float32}, 
          yj      :: Array{Float64} or Array{Float32}, 
          zj      :: Array{Float64} or Array{Float32}, 
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
        )</code></pre><p>Compute type-1 3D complex nonuniform FFT. Output stored in fk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L642-L654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft3d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer, Integer, Integer}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft3d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer, Integer, Integer}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft3d1(xj      :: Array{Float64} or Array{Float32}, 
         yj      :: Array{Float64} or Array{Float32}, 
         zj      :: Array{Float64} or Array{Float32}, 
         cj      :: Array{ComplexF64} or Array{ComplexF32}, 
         iflag   :: Integer, 
         eps     :: Real,
         ms      :: Integer,
         mt      :: Integer,
         mu      :: Integer;
         kwargs...
        ) -&gt; Array{ComplexF64}</code></pre><p>Compute type-1 3D complex nonuniform FFT. This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">                  nj
f[k1,k2,k3] =    SUM  c[j] exp(+-i (k1 x[j] + k2 y[j] + k3 z[j]))
                 j=1

for -ms/2 &lt;= k1 &lt;= (ms-1)/2,  -mt/2 &lt;= k2 &lt;= (mt-1)/2,
    -mu/2 &lt;= k3 &lt;= (mu-1)/2.</code></pre><p>Inputs:     xj,yj,zj coordinates of nonuniform sources on the cube [-3pi,3pi)^3,              each a length-nj vector     cj       length-nj complex vector of source strengths. If length(cj)&gt;nj,              expects a stack of vectors (eg, a nj*ntrans matrix) each of which is              transformed with the same source locations.     iflag    if &gt;=0, uses + sign in exponential, otherwise - sign.     eps      relative precision requested (generally between 1e-15 and 1e-1)     ms,mt,mu number of Fourier modes requested in x,y and z; each may be              even or odd.              In either case the mode range is integers lying in [-m/2, (m-1)/2]     kwargs  (optional), for more options, see https://finufft.readthedocs.io/en/latest/opts.html   Outputs:     fk      size (ms,mt,mu) complex array of Fourier coefficients             (ordering given by opts.modeord in each dimension; ms fastest, mu             slowest), or, if ntrans&gt;1, a 4D array of size (ms,mt,mu,ntrans).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L102-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft3d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft3d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft3d2!(xj      :: Array{Float64} or Array{Float32}, 
          yj      :: Array{Float64} or Array{Float32}, 
          zj      :: Array{Float64} or Array{Float32}, 
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
        )</code></pre><p>Compute type-2 3D complex nonuniform FFT. Output stored in cj.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L676-L688">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft3d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft3d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft3d2(xj      :: Array{Float64} or Array{Float32}, 
         yj      :: Array{Float64} or Array{Float32}, 
         zj      :: Array{Float64} or Array{Float32}, 
         iflag   :: Integer, 
         eps     :: Real,
         fk      :: Array{ComplexF64} or Array{ComplexF32};
         kwargs...
        ) -&gt; Array{ComplexF64}</code></pre><p>Compute type-2 3D complex nonuniform FFT.  This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">c[j] =   SUM   f[k1,k2,k3] exp(+/-i (k1 x[j] + k2 y[j] + k3 z[j]))
       k1,k2,k3
                       for j = 1,..,nj
 where sum is over -ms/2 &lt;= k1 &lt;= (ms-1)/2, -mt/2 &lt;= k2 &lt;= (mt-1)/2,
                  -mu/2 &lt;= k3 &lt;= (mu-1)/2.</code></pre><p>Inputs:     xj,yj,zj coordinates of nonuniform targets on the cube [-3pi,3pi)^3,              each a vector of length nj     fk       complex Fourier coefficient array, whose size sets (ms,mt,mu).              (Mode ordering given by opts.modeord, in each dimension.)              If a 4D array, 4th dimension sets ntrans, and each of ntrans              3D arrays is transformed with the same nonuniform targets.     iflag    if &gt;=0, uses + sign in exponential, otherwise - sign.     eps      relative precision requested (generally between 1e-15 and 1e-1)     kwargs   (optional), for more options, see https://finufft.readthedocs.io/en/latest/opts.html   Outputs:     cj       complex column vector of nj answers at targets, or,              if ntrans&gt;1, matrix of size (nj,ntrans).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L250-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft3d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft3d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d3!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft3d3!(xj      :: Array{Float64} or Array{Float32}, 
          yj      :: Array{Float64} or Array{Float32},
          zj      :: Array{Float64} or Array{Float32},
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          sk      :: Array{Float64} or Array{Float32},
          tk      :: Array{Float64} or Array{Float32},
          uk      :: Array{Float64} or Array{Float32},
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
         )</code></pre><p>Compute type-3 3D complex nonuniform FFT. Output stored in fk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L708-L723">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft3d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft3d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft3d3(xj      :: Array{Float64} or Array{Float32}, 
         yj      :: Array{Float64} or Array{Float32},
         zj      :: Array{Float64} or Array{Float32},
         cj      :: Array{ComplexF64} or Array{ComplexF32}, 
         iflag   :: Integer, 
         eps     :: Real,
         sk      :: Array{Float64} or Array{Float32},
         tk      :: Array{Float64} or Array{Float32},
         uk      :: Array{Float64} or Array{Float32};
         kwargs...
        ) -&gt; Array{ComplexF64}</code></pre><p>Compute type-3 3D complex nonuniform FFT. This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">         nj
f[k]  =  SUM   c[j] exp(+-i (s[k] x[j] + t[k] y[j] + u[k] z[j])),
         j=1
                         for k = 1, ..., nk</code></pre><p>Inputs:     xj,yj,zj coordinates of nonuniform sources in R^3, each a length-nj vector.     cj       length-nj complex vector of source strengths. If length(cj)&gt;nj,              expects a stack of vectors (eg, a nj*ntrans matrix) each of which is              transformed with the same source and target locations.     iflag    if &gt;=0, uses + sign in exponential, otherwise - sign.     eps      relative precision requested (generally between 1e-15 and 1e-1)     sk,tk,uk frequency coordinates of nonuniform targets in R^3,              each a length-nk vector.     kwargs   (optional), for more options, see https://finufft.readthedocs.io/en/latest/opts.html   Outputs:     fk       length-nk complex vector of values at targets, or, if ntrans&gt;1,              a matrix of size (nk,ntrans)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/ffd38ac99b10cca22e3b4eaff99b305974ceeace/src/simple.jl#L393-L427">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 1 November 2021 23:45">Monday 1 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
