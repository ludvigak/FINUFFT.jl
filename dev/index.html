<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>FINUFFT.jl Reference · FINUFFT.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FINUFFT.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>FINUFFT.jl Reference</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li class="toplevel"><a class="tocitem" href="#Types"><span>Types</span></a></li><li class="toplevel"><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>FINUFFT.jl Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>FINUFFT.jl Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ludvigak/FINUFFT.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="FINUFFT.jl-Reference"><a class="docs-heading-anchor" href="#FINUFFT.jl-Reference">FINUFFT.jl Reference</a><a id="FINUFFT.jl-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#FINUFFT.jl-Reference" title="Permalink"></a></h1><p>For installation and basic usage, see the README at <a href="https://github.com/ludvigak/FINUFFT.jl">https://github.com/ludvigak/FINUFFT.jl</a></p><p>For documentation of the library functions that are being called, see the FINUFFT documentation at <a href="https://finufft.readthedocs.io">https://finufft.readthedocs.io</a></p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#FINUFFT.nufft_opts"><code>FINUFFT.nufft_opts</code></a></li><li><a href="#FINUFFT.finufft_default_opts"><code>FINUFFT.finufft_default_opts</code></a></li><li><a href="#FINUFFT.finufft_destroy-Union{Tuple{finufft_plan{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.finufft_destroy</code></a></li><li><a href="#FINUFFT.finufft_exec-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.finufft_exec</code></a></li><li><a href="#FINUFFT.finufft_exec!-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{Complex{T}, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.finufft_exec!</code></a></li><li><a href="#FINUFFT.finufft_makeplan-Tuple{Integer, Union{Integer, Array{Int64, N} where N}, Integer, Integer, Real}"><code>FINUFFT.finufft_makeplan</code></a></li><li><a href="#FINUFFT.finufft_setpts-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.finufft_setpts</code></a></li><li><a href="#FINUFFT.nufft1d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d1</code></a></li><li><a href="#FINUFFT.nufft1d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d1!</code></a></li><li><a href="#FINUFFT.nufft1d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d2</code></a></li><li><a href="#FINUFFT.nufft1d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d2!</code></a></li><li><a href="#FINUFFT.nufft1d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d3</code></a></li><li><a href="#FINUFFT.nufft1d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d3!</code></a></li><li><a href="#FINUFFT.nufft2d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer, Integer}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d1</code></a></li><li><a href="#FINUFFT.nufft2d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d1!</code></a></li><li><a href="#FINUFFT.nufft2d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d2</code></a></li><li><a href="#FINUFFT.nufft2d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d2!</code></a></li><li><a href="#FINUFFT.nufft2d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d3</code></a></li><li><a href="#FINUFFT.nufft2d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d3!</code></a></li><li><a href="#FINUFFT.nufft3d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer, Integer, Integer}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d1</code></a></li><li><a href="#FINUFFT.nufft3d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d1!</code></a></li><li><a href="#FINUFFT.nufft3d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d2</code></a></li><li><a href="#FINUFFT.nufft3d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d2!</code></a></li><li><a href="#FINUFFT.nufft3d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d3</code></a></li><li><a href="#FINUFFT.nufft3d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d3!</code></a></li></ul><h1 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft_opts" href="#FINUFFT.nufft_opts"><code>FINUFFT.nufft_opts</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct nufft_opts    
    modeord            :: Cint
    chkbnds            :: Cint
    debug              :: Cint
    spread_debug       :: Cint
    showwarn           :: Cint
    nthreads           :: Cint
    fftw               :: Cint
    spread_sort        :: Cint
    spread_kerevalmeth :: Cint
    spread_kerpad      :: Cint
    upsampfac          :: Cdouble
    spread_thread      :: Cint
    maxbatchsize       :: Cint
    spread_nthr_atomic :: Cint
    spread_max_sp_size :: Cint
end</code></pre><p>Options struct passed to the FINUFFT library.</p><p><strong>Fields</strong></p><p>This is a summary only; see FINUFFT documentation for full descriptions.</p><pre><code class="language-none">modeord :: Cint</code></pre><p>0: CMCL-style increasing mode ordering (neg to pos), or<br/>1: FFT-style mode ordering (affects type-1,2 only)</p><pre><code class="language-none">chkbnds :: Cint</code></pre><p>0: don&#39;t check if input NU pts in [-3pi,3pi], 1: do</p><pre><code class="language-none">debug :: Cint</code></pre><p>0: silent, 1: text basic timing output</p><pre><code class="language-none">spread_debug :: Cint</code></pre><p>passed to spread_opts, 0 (no text) 1 (some) or 2 (lots)</p><pre><code class="language-none">showwarn :: Cint</code></pre><p>Whether to print warnings to stderr. 0: silent, 1: print warnings</p><pre><code class="language-none">nthreads :: Cint</code></pre><p>How many threads FINUFFT should use, or 0 (use max available in OMP)</p><pre><code class="language-none">fftw :: Cint</code></pre><p>0:<code>FFTW_ESTIMATE</code>, or 1:<code>FFTW_MEASURE</code> (slow plan but faster FFTs)</p><pre><code class="language-none">spread_sort :: Cint</code></pre><p>passed to spread_opts, 0 (don&#39;t sort) 1 (do) or 2 (heuristic)</p><pre><code class="language-none">spread_kerevalmeth :: Cint</code></pre><p>passed to spread_opts, 0: exp(sqrt()), 1: Horner ppval (faster)</p><pre><code class="language-none">spread_kerpad :: Cint</code></pre><p>passed to spread_opts, 0: don&#39;t pad to mult of 4, 1: do</p><pre><code class="language-none">upsampfac :: Cdouble</code></pre><p>upsampling ratio sigma: 2.0 (standard), or 1.25 (small FFT), or<br/>0.0 (auto).</p><pre><code class="language-none">spread_thread :: Cint</code></pre><p>(for ntrans&gt;1 only)<br/>0: auto choice,<br/>1: sequential multithreaded,<br/>2: parallel singlethreaded spread.</p><pre><code class="language-none">maxbatchsize :: Cint</code></pre><p>(for ntrans&gt;1 only). max blocking size for vectorized, 0 for auto-set</p><pre><code class="language-none">spread_nthr_atomic :: Cint</code></pre><p>if &gt;=0, threads above which spreader OMP critical goes atomic</p><pre><code class="language-none">spread_max_sp_size :: Cint</code></pre><p>if &gt;0, overrides spreader (dir=1 only) max subproblem size</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/FINUFFT.jl#L36-L110">source</a></section></article><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.finufft_default_opts" href="#FINUFFT.finufft_default_opts"><code>FINUFFT.finufft_default_opts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">p = finufft_default_opts()
p = finufft_default_opts(dtype=Float32)</code></pre><p>Return a <a href="#FINUFFT.nufft_opts"><code>nufft_opts</code></a> struct with the default FINUFFT settings. Set up the double precision variant by default.<br/>See: <a href="https://finufft.readthedocs.io/en/latest/usage.html#options">https://finufft.readthedocs.io/en/latest/usage.html#options</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/FINUFFT.jl#L135-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.finufft_destroy-Union{Tuple{finufft_plan{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.finufft_destroy-Union{Tuple{finufft_plan{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.finufft_destroy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">status = finufft_destroy(plan::finufft_plan{T}) where T &lt;: finufftReal</code></pre><p>This destroys a FINUFFT plan object: it deallocates all stored FFTW plans, nonuniform point sorting arrays, kernel Fourier transforms arrays, and any other allocations, and nulls the plan pointer.</p><p>An integer status code is returned, that is 0 if successful. If one attempts to destroy an already-destroyed plan, 1 is returned (see FINUFFT documentation for finufft_destroy).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/guru.jl#L263-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.finufft_exec!-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{Complex{T}, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.finufft_exec!-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{Complex{T}, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.finufft_exec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">finufft_exec!(plan::finufft_plan{T},
                  input::Array{Complex{T}},
                  output::Array{Complex{T}}) where T &lt;: finufftReal</code></pre><p>Execute single or many-vector FINUFFT transforms in a plan, with output written to preallocated array. See <code>finufft_exec</code> for arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/guru.jl#L294-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.finufft_exec-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.finufft_exec-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.finufft_exec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">output::Array{Complex{T}} = finufft_exec(plan::finufft_plan{T},
                  input::Array{Complex{T}}) where T &lt;: finufftReal</code></pre><p>Execute single or many-vector FINUFFT transforms in a plan.</p><p>output = finufft_exec(plan, input)</p><p>For <code>plan</code> a previously created <code>finufft_plan</code> object also containing all   needed nonuniform point coordinates, do a single (or if <code>ntrans&gt;1</code> in the   plan stage, multiple) NUFFT transform(s), with the strengths or Fourier   coefficient inputs vector(s) from <code>input</code>. The result of the transform(s)   is returned as a (possibly multidimensional) array.</p><p><strong>Inputs</strong></p><pre><code class="language-none">- `plan`     `finufft_plan` object, already planned and containing
nonuniform points.
- `input`    strengths (types 1 or 3) or Fourier coefficients (type 2)
          vector, matrix, or array of appropriate size. For type 1 and 3,
          this is either a length-M vector (where M is the length of `xj`),
          or an `(M,ntrans)` matrix when `ntrans&gt;1`. For type 2, in 1D this is size `(ms,)`, in 2D size `(ms,mt)`, or in 3D size `(ms,mt,mu)`, or
          each of these with an extra last dimension `ntrans` if `ntrans&gt;1`.</code></pre><p><strong>Output</strong></p><pre><code class="language-none"> `output`   vector of output strengths at targets (types 2 or 3), or array
          of Fourier coefficients (type 1), or, if `ntrans&gt;1`, a stack of
          such vectors or arrays, of appropriate size.
          Specifically, if `ntrans=1`, for type 1, in 1D
          this is size `(ms,)`, in 2D size
          `(ms,mt)`, or in 3D size `(ms,mt,mu)`; for types 2 and 3
          it is a column vector of length `M` (the length of `xj` in type 2),
          or `nk` (the length of `s` in type 3). If `ntrans&gt;1` it is a stack
          of such objects, ie, it has an extra last dimension `ntrans`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/guru.jl#L196-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.finufft_makeplan-Tuple{Integer, Union{Integer, Array{Int64, N} where N}, Integer, Integer, Real}" href="#FINUFFT.finufft_makeplan-Tuple{Integer, Union{Integer, Array{Int64, N} where N}, Integer, Integer, Real}"><code>FINUFFT.finufft_makeplan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">finufft_makeplan(type::Integer,
                      n_modes_or_dim::Union{Array{Int64},Integer},
                      iflag::Integer,
                      ntrans::Integer,
                      eps::Real;
                      dtype=Float64,
                      kwargs...)</code></pre><p>Creates a <code>finufft_plan</code> object for the guru interface to FINUFFT, of  type 1, 2 or 3, and with given numbers of Fourier modes (unless type 3).</p><p><strong>Inputs</strong></p><ul><li><code>type</code>            transform type: 1, 2, or 3</li><li><code>n_modes_or_dim</code>  if <code>type</code> is 1 or 2, the number of Fourier modes in each                 dimension: <code>ms</code> in 1D, <code>[ms mt]</code> in 2D, or <code>[ms mt mu]</code> in 3D.                 Its length thus sets the dimension, which must be 1, 2 or 3.                 If <code>type</code> is 3, in contrast, its <em>value</em> fixes the dimension.</li><li><code>iflag</code>   if &gt;=0, uses + sign in exponential, otherwise - sign.</li><li><code>ntrans</code>          number of transforms to compute simultaneously</li><li><code>eps</code>     relative precision requested (generally between 1e-15 and 1e-1),         real, need not match type of <code>dtype</code></li><li><code>dtype</code>           <code>Float32</code> or <code>Float64</code>, plan for single precision or double precision</li><li><code>kwargs</code>  (optional): for options, see <code>nufft_opts</code> and https://finufft.readthedocs.io/en/latest/opts.html</li></ul><p><strong>Returns</strong></p><ul><li>finufft_plan struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; p = finufft_makeplan(2,10,+1,1,1e-6);</code></pre><p>creates a plan for a 1D type 2 Float64 transform with 10 Fourier modes and tolerance 1e-6.</p><pre><code class="language-julia-repl">julia&gt; p = finufft_makeplan(1,[10 20],+1,1,1e-6);</code></pre><p>creates a plan for a 2D type 1 Float64 transform with 10*20 Fourier modes.</p><pre><code class="language-julia-repl">julia&gt; p = finufft_makeplan(3,2,+1,1,1e-4,dtype=Float32,nthreads=4);</code></pre><p>creates a plan for a 2D type 3 Float32 transform with tolerance 1e-4, to use 4 threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/guru.jl#L18-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.finufft_setpts-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.finufft_setpts-Union{Tuple{T}, Tuple{finufft_plan{T}, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}, Tuple{finufft_plan{T}, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.finufft_setpts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">finufft_setpts(plan, xj [, yj[, zj[, s[, t[, u]]]]])</code></pre><p>Input nonuniform points for general FINUFFT transform(s).</p><p>Given an already-planned <code>finufft_plan</code>, this reads in nonuniform point  coordinate arrays <code>xj</code> (and <code>yj</code> if 2D or 3D, and <code>zj</code> if 3D), and additionally in the type 3 case, nonuniform  frequency target coordinate arrays <code>s</code> (and <code>t</code> if 2D or 3D, and <code>u</code> if 3D). Empty arrays may be passed in the case of  unused dimensions. For all types, sorting is done to internally store a  reindexing of points, and for type 3 the spreading and FFTs are planned.  These nonuniform points may then be used for multiple transforms.</p><p><strong>Inputs</strong></p><ul><li><code>plan</code>   a <code>finufft_plan</code> object for one/many general nonuniform FFTs</li><li><code>xj</code> Array{Float32} or Array{Float64}, vector of x-coords of all nonuniform points</li><li><code>yj</code>     empty (if dim&lt;2), or vector of y-coords of all nonuniform points</li><li><code>zj</code>     empty (if dim&lt;3), or vector of z-coords of all nonuniform points</li><li><code>s</code>      vector of x-coords of all nonuniform frequency targets</li><li><code>t</code>      empty (if dim&lt;2), or vector of y-coords of all frequency targets</li><li><code>u</code>      empty (if dim&lt;3), or vector of z-coords of all frequency targets</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/guru.jl#L125-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft1d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft1d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d1!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft1d1!(xj      :: Array{Float64} or Array{Float32}, 
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
        )</code></pre><p>Compute type-1 1D complex nonuniform FFT. Output written to <code>fk</code>. See <code>nufft1d1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L447-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft1d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft1d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft1d1(xj      :: Array{Float64} or Array{Float32}, 
         cj      :: Array{ComplexF64} or Array{ComplexF32}, 
         iflag   :: Integer, 
         eps     :: Real,
         ms      :: Integer;
         kwargs...
        ) -&gt; Array{ComplexF64} or Array{ComplexF32}</code></pre><p>Compute type-1 1D complex nonuniform FFT.  This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">          nj
f(k1) =  SUM c[j] exp(+/-i k1 x(j))  for -ms/2 &lt;= k1 &lt;= (ms-1)/2
         j=1</code></pre><p><strong>Inputs</strong></p><ul><li><code>xj</code>      locations of nonuniform sources on interval [-3pi,3pi), length nj</li><li><code>cj</code>      length-nj complex vector of source strengths. If length(cj)&gt;nj,         expects a stack of vectors (eg, a nj*ntrans matrix) each of which is         transformed with the same source locations.</li><li><code>iflag</code>   if &gt;=0, uses + sign in exponential, otherwise - sign.</li><li><code>eps</code>     relative precision requested (generally between 1e-15 and 1e-1)</li><li><code>ms</code>      number of Fourier modes computed, may be even or odd;         in either case, mode range is integers lying in [-ms/2, (ms-1)/2]</li><li>kwargs  (optional). See <code>nufft_opts</code> and https://finufft.readthedocs.io/en/latest/opts.html</li></ul><p><strong>Output</strong></p><ul><li>size <code>(ms,)</code> complex vector of Fourier coefficients f, or, if         <code>ntrans&gt;1</code>, matrix of size <code>(ms,ntrans)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L5-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft1d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft1d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft1d2!(xj      :: Array{Float64} or Array{Float32}, 
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
        )</code></pre><p>Compute type-2 1D complex nonuniform FFT. Output written to <code>cj</code>. See <code>nufft1d2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L477-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft1d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft1d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft1d2(xj      :: Array{Float64} or Array{Float32}, 
         iflag   :: Integer, 
         eps     :: Real,
         fk      :: Array{ComplexF64} or Array{ComplexF32};
         kwargs...
        ) -&gt; Array{ComplexF64}</code></pre><p>Compute type-2 1D complex nonuniform FFT.  This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">c[j] = SUM   f[k1] exp(+/-i k1 x[j])      for j = 1,...,nj
        k1
 where sum is over -ms/2 &lt;= k1 &lt;= (ms-1)/2.</code></pre><p><strong>Input</strong></p><ul><li><code>xj</code>      location of nonuniform targets on interval [-3pi,3pi), length nj</li><li><code>fk</code>      complex Fourier coefficients. If a vector, length sets <code>ms</code>         (with mode ordering given by opts.modeord). If a matrix, each         column is transformed with the same nonuniform targets.</li><li><code>iflag</code>   if &gt;=0, uses + sign in exponential, otherwise - sign.</li><li><code>eps</code>     relative precision requested (generally between 1e-15 and 1e-1)</li><li>kwargs  (optional). See <code>nufft_opts</code> and https://finufft.readthedocs.io/en/latest/opts.html</li></ul><p><strong>Output</strong></p><ul><li>complex <code>(nj,)</code> vector c of answers at targets, or,        if <code>ntrans&gt;1</code>, matrix of size <code>(nj,ntrans)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L162-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft1d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft1d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d3!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft1d3!(xj      :: Array{Float64} or Array{Float32}, 
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          sk      :: Array{Float64} or Array{Float32},
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
         )</code></pre><p>Compute type-3 1D complex nonuniform FFT. Output written to <code>fk</code>. See <code>nufft1d3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L506-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft1d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft1d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft1d3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft1d3(xj      :: Array{Float64} or Array{Float32}, 
         cj      :: Array{ComplexF64} or Array{ComplexF32}, 
         iflag   :: Integer, 
         eps     :: Real,
         sk      :: Array{Float64} or Array{Float32};
         kwargs...
        ) -&gt; Array{ComplexF64}</code></pre><p>Compute type-3 1D complex nonuniform FFT. This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">         nj
f[k]  =  SUM   c[j] exp(+-i s[k] x[j]),      for k = 1, ..., nk
         j=1</code></pre><p><strong>Inputs</strong></p><ul><li><code>xj</code>       locations of nonuniform sources on R (real line), length-nj vector.</li><li><code>cj</code>       length-nj complex vector of source strengths. If length(cj)&gt;nj,           expects a size <code>(nj,ntrans)</code> matrix each column of which is           transformed with the same source and target locations.</li><li><code>iflag</code>    if &gt;=0, uses + sign in exponential, otherwise - sign.</li><li><code>eps</code>      relative precision requested (generally between 1e-15 and 1e-1)</li><li><code>sk</code>       frequency locations of nonuniform targets on R, length-nk vector.</li><li>kwargs   (optional). See <code>nufft_opts</code> and https://finufft.readthedocs.io/en/latest/opts.html</li></ul><p><strong>Output</strong></p><ul><li>complex vector f size &#39;(nk,)<code>of values at targets, or, if</code>ntrans&gt;1<code>,          a matrix of size</code>(nk,ntrans)`</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L298-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft2d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft2d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d1!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft2d1!(xj      :: Array{Float64} or Array{Float32}, 
          yj      :: Array{Float64} or Array{Float32}, 
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
        )</code></pre><p>Compute type-1 2D complex nonuniform FFT. Output written to <code>fk</code>. See <code>nufft2d1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L539-L550">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft2d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer, Integer}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft2d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer, Integer}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft2d1(xj      :: Array{Float64} or Array{Float32}
         yj      :: Array{Float64} or Array{Float32}, 
         cj      :: Array{ComplexF64} or Array{ComplexF32}, 
         iflag   :: Integer, 
         eps     :: Real,
         ms      :: Integer,
         mt      :: Integer;
         kwargs...
        ) -&gt; Array{ComplexF64}</code></pre><p>Compute type-1 2D complex nonuniform FFT. This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">              nj
f[k1,k2] =   SUM  c[j] exp(+-i (k1 x[j] + k2 y[j]))
             j=1

for -ms/2 &lt;= k1 &lt;= (ms-1)/2,  -mt/2 &lt;= k2 &lt;= (mt-1)/2.</code></pre><p><strong>Inputs</strong></p><ul><li><code>xj</code>,<code>yj</code>   coordinates of nonuniform sources on the square [-3pi,3pi)^2,         each a length-nj vector</li><li><code>cj</code>      length-nj complex vector of source strengths. If length(cj)&gt;nj,         expects a stack of vectors (eg, a nj*ntrans matrix) each of which is         transformed with the same source locations.</li><li><code>iflag</code>   if &gt;=0, uses + sign in exponential, otherwise - sign.</li><li><code>eps</code>     relative precision requested (generally between 1e-15 and 1e-1)</li><li><code>ms</code>,<code>mt</code>   number of Fourier modes requested in x &amp; y; each may be even or odd.         In either case the mode range is integers lying in [-m/2, (m-1)/2]</li><li>kwargs  (optional), see <code>nufft_opts</code> and https://finufft.readthedocs.io/en/latest/opts.html</li></ul><p><strong>Output</strong></p><ul><li>size <code>(ms,mt)</code> complex matrix of Fourier coefficients f         (ordering given by opts.modeord in each dimension; <code>ms</code> fast, <code>mt</code> slow),         or, if <code>ntrans&gt;1</code>, a array of size <code>(ms,mt,ntrans)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L49-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft2d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft2d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft2d2!(xj      :: Array{Float64} or Array{Float32}, 
          yj      :: Array{Float64} or Array{Float32}, 
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
        )</code></pre><p>Compute type-2 2D complex nonuniform FFT. Output written to <code>cj</code>. See <code>nufft2d2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L572-L583">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft2d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft2d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft2d2(xj      :: Array{Float64} or Array{Float32}, 
         yj      :: Array{Float64} or Array{Float32}, 
         iflag   :: Integer, 
         eps     :: Real,
         fk      :: Array{ComplexF64} or Array{ComplexF32};
         kwargs...
        ) -&gt; Array{ComplexF64}</code></pre><p>Compute type-2 2D complex nonuniform FFT.  This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">c[j] =  SUM   f[k1,k2] exp(+/-i (k1 x[j] + k2 y[j]))  for j = 1,..,nj
       k1,k2
 where sum is over -ms/2 &lt;= k1 &lt;= (ms-1)/2, -mt/2 &lt;= k2 &lt;= (mt-1)/2,</code></pre><p><strong>Inputs</strong></p><ul><li><code>xj</code>,<code>yj</code>   coordinates of nonuniform targets on the square [-3pi,3pi)^2,        each a vector of length nj</li><li><code>fk</code>      complex Fourier coefficient matrix, whose size determines (ms,mt).        (Mode ordering given by opts.modeord, in each dimension.)        If a 3D array, 3rd dimension sets <code>ntrans</code>, and each of <code>ntrans</code>        matrices is transformed with the same nonuniform targets.</li><li><code>iflag</code>   if &gt;=0, uses + sign in exponential, otherwise - sign.</li><li><code>eps</code>     relative precision requested (generally between 1e-15 and 1e-1)</li><li>kwargs  (optional). See <code>nufft_opts</code> and https://finufft.readthedocs.io/en/latest/opts.html</li></ul><p><strong>Output</strong></p><ul><li>complex size <code>(nj,)</code> vector c of answers at targets, or,        if <code>ntrans&gt;1</code>, matrix of size <code>(nj,ntrans)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L202-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft2d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft2d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d3!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft2d3!(xj      :: Array{Float64} or Array{Float32}, 
          yj      :: Array{Float64} or Array{Float32},
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          sk      :: Array{Float64} or Array{Float32},
          tk      :: Array{Float64} or Array{Float32},
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
         )</code></pre><p>Compute type-3 2D complex nonuniform FFT. Output written to &#39;fk&#39;. See <code>nufft2d3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L602-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft2d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft2d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft2d3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft2d3(xj      :: Array{Float64} or Array{Float32}, 
         yj      :: Array{Float64} or Array{Float32},
         cj      :: Array{ComplexF64} or Array{ComplexF32}, 
         iflag   :: Integer, 
         eps     :: Real,
         sk      :: Array{Float64} or Array{Float32},
         tk      :: Array{Float64} or Array{Float32};
         kwargs...
        ) -&gt; Array{ComplexF64}</code></pre><p>Compute type-3 2D complex nonuniform FFT. This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">         nj
f[k]  =  SUM   c[j] exp(+-i (s[k] x[j] + t[k] y[j])),  for k = 1, ..., nk
         j=1</code></pre><p><strong>Inputs</strong></p><ul><li><code>xj</code>,<code>yj</code>    coordinates of nonuniform sources in R^2, each a length-nj vector.</li><li><code>cj</code>    complex vector <code>(nj,)</code> of source strengths. If length(cj)&gt;nj,          expects a <code>(nj,ntrans)</code> matrix, each column of which is          transformed with the same source and target locations.</li><li><code>iflag</code>    if &gt;=0, uses + sign in exponential, otherwise - sign.</li><li><code>eps</code>      relative precision requested (generally between 1e-15 and 1e-1)</li><li><code>sk</code>,<code>tk</code>    frequency coordinates of nonuniform targets in R^2,          each a length-nk vector.</li><li>kwargs   (optional). See <code>nufft_opts</code> and https://finufft.readthedocs.io/en/latest/opts.html</li></ul><p><strong>Output</strong></p><ul><li>complex vector size <code>(nk,)</code> of values at targets, or, if <code>ntrans&gt;1</code>,          a matrix of size <code>(nk,ntrans)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L341-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft3d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft3d1!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d1!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft3d1!(xj      :: Array{Float64} or Array{Float32}, 
          yj      :: Array{Float64} or Array{Float32}, 
          zj      :: Array{Float64} or Array{Float32}, 
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
        )</code></pre><p>Compute type-1 3D complex nonuniform FFT. Output written to <code>fk</code>. See <code>nufft3d1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L638-L650">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft3d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer, Integer, Integer}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft3d1-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Integer, Integer, Integer}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft3d1(xj      :: Array{Float64} or Array{Float32}, 
         yj      :: Array{Float64} or Array{Float32}, 
         zj      :: Array{Float64} or Array{Float32}, 
         cj      :: Array{ComplexF64} or Array{ComplexF32}, 
         iflag   :: Integer, 
         eps     :: Real,
         ms      :: Integer,
         mt      :: Integer,
         mu      :: Integer;
         kwargs...
        ) -&gt; Array{ComplexF64}</code></pre><p>Compute type-1 3D complex nonuniform FFT. This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">                  nj
f[k1,k2,k3] =    SUM  c[j] exp(+-i (k1 x[j] + k2 y[j] + k3 z[j]))
                 j=1

for -ms/2 &lt;= k1 &lt;= (ms-1)/2,  -mt/2 &lt;= k2 &lt;= (mt-1)/2,
    -mu/2 &lt;= k3 &lt;= (mu-1)/2.</code></pre><p><strong>Inputs</strong></p><ul><li><code>xj</code>,<code>yj</code>,<code>zj</code> coordinates of nonuniform sources on the cube [-3pi,3pi)^3,           each a length-nj vector</li><li><code>cj</code>       length-nj complex vector of source strengths. If length(cj)&gt;nj,           expects a stack of vectors (eg, a nj*ntrans matrix) each of which is           transformed with the same source locations.</li><li><code>iflag</code>    if &gt;=0, uses + sign in exponential, otherwise - sign.</li><li><code>eps</code>      relative precision requested (generally between 1e-15 and 1e-1)</li><li><code>ms</code>,<code>mt</code>,<code>mu</code> number of Fourier modes requested in x,y and z; each may be           even or odd.           In either case the mode range is integers lying in [-m/2, (m-1)/2]</li><li>kwargs  (optional). See <code>nufft_opts</code> and https://finufft.readthedocs.io/en/latest/opts.html</li></ul><p><strong>Output</strong></p><ul><li>size <code>(ms,mt,mu)</code> complex array of Fourier coefficients f         (ordering given by opts.modeord in each dimension; <code>ms</code> fastest, <code>mu</code>         slowest), or, if <code>ntrans&gt;1</code>, a 4D array of size <code>(ms,mt,mu,ntrans)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L101-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft3d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft3d2!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft3d2!(xj      :: Array{Float64} or Array{Float32}, 
          yj      :: Array{Float64} or Array{Float32}, 
          zj      :: Array{Float64} or Array{Float32}, 
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
        )</code></pre><p>Compute type-2 3D complex nonuniform FFT. Output written to <code>cj</code>. See <code>nufft3d2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L672-L684">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft3d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft3d2-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Integer, Real, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft3d2(xj      :: Array{Float64} or Array{Float32}, 
         yj      :: Array{Float64} or Array{Float32}, 
         zj      :: Array{Float64} or Array{Float32}, 
         iflag   :: Integer, 
         eps     :: Real,
         fk      :: Array{ComplexF64} or Array{ComplexF32};
         kwargs...
        ) -&gt; Array{ComplexF64}</code></pre><p>Compute type-2 3D complex nonuniform FFT.  This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">c[j] =   SUM   f[k1,k2,k3] exp(+/-i (k1 x[j] + k2 y[j] + k3 z[j]))
       k1,k2,k3
                       for j = 1,..,nj
 where sum is over -ms/2 &lt;= k1 &lt;= (ms-1)/2, -mt/2 &lt;= k2 &lt;= (mt-1)/2,
                  -mu/2 &lt;= k3 &lt;= (mu-1)/2.</code></pre><p><strong>Inputs</strong></p><ul><li><code>xj</code>,<code>yj</code>,<code>zj</code> coordinates of nonuniform targets on the cube [-3pi,3pi)^3,          each a vector of length nj</li><li><code>fk</code>       complex Fourier coefficient array, whose size sets <code>(ms,mt,mu)</code>.          (Mode ordering given by opts.modeord, in each dimension.)          If a 4D array, 4th dimension sets <code>ntrans</code>, and each of <code>ntrans</code>          3D arrays is transformed with the same nonuniform targets.</li><li><code>iflag</code>    if &gt;=0, uses + sign in exponential, otherwise - sign.</li><li><code>eps</code>      relative precision requested (generally between 1e-15 and 1e-1)</li><li>kwargs   (optional). See <code>nufft_opts</code> and https://finufft.readthedocs.io/en/latest/opts.html</li></ul><p><strong>Output</strong></p><ul><li>complex vector c of size <code>(nj,)</code> giving answers at targets, or,         if <code>ntrans&gt;1</code>, matrix of size <code>(nj,ntrans)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L247-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft3d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft3d3!-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d3!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft3d3!(xj      :: Array{Float64} or Array{Float32}, 
          yj      :: Array{Float64} or Array{Float32},
          zj      :: Array{Float64} or Array{Float32},
          cj      :: Array{ComplexF64} or Array{ComplexF32}, 
          iflag   :: Integer, 
          eps     :: Real,
          sk      :: Array{Float64} or Array{Float32},
          tk      :: Array{Float64} or Array{Float32},
          uk      :: Array{Float64} or Array{Float32},
          fk      :: Array{ComplexF64} or Array{ComplexF32};
          kwargs...
         )</code></pre><p>Compute type-3 3D complex nonuniform FFT. Output written to <code>fk</code>. See <code>nufft3d3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L704-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FINUFFT.nufft3d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}" href="#FINUFFT.nufft3d3-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N, Array{T, N} where N, Array{Complex{T}, N} where N, Integer, Real, Array{T, N} where N, Array{T, N} where N, Array{T, N} where N}} where T&lt;:Union{Float32, Float64}"><code>FINUFFT.nufft3d3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nufft3d3(xj      :: Array{Float64} or Array{Float32}, 
         yj      :: Array{Float64} or Array{Float32},
         zj      :: Array{Float64} or Array{Float32},
         cj      :: Array{ComplexF64} or Array{ComplexF32}, 
         iflag   :: Integer, 
         eps     :: Real,
         sk      :: Array{Float64} or Array{Float32},
         tk      :: Array{Float64} or Array{Float32},
         uk      :: Array{Float64} or Array{Float32};
         kwargs...
        ) -&gt; Array{ComplexF64}</code></pre><p>Compute type-3 3D complex nonuniform FFT. This computes, to relative precision eps, via a fast algorithm:</p><pre><code class="language-none">         nj
f[k]  =  SUM   c[j] exp(+-i (s[k] x[j] + t[k] y[j] + u[k] z[j])),
         j=1
                         for k = 1, ..., nk</code></pre><p><strong>Inputs</strong></p><ul><li><code>xj</code>,<code>yj</code>,<code>zj</code> coordinates of nonuniform sources in R^3, each a length-nj vector.</li><li><code>cj</code>     complex <code>(nj,)</code> vector of source strengths. If length(cj)&gt;nj,          expects a &#39;(nj,ntrans)&#39; matrix, each column of which is          transformed with the same source and target locations.</li><li><code>iflag</code>    if &gt;=0, uses + sign in exponential, otherwise - sign.</li><li><code>eps</code>      relative precision requested (generally between 1e-15 and 1e-1)</li><li><code>sk</code>,<code>tk,</code>uk` frequency coordinates of nonuniform targets in R^3,          each a length-nk vector.</li><li>kwargs   (optional). See <code>nufft_opts</code> and https://finufft.readthedocs.io/en/latest/opts.html</li></ul><p><strong>Output</strong></p><ul><li>size <code>(nk,)</code> complex vector f values at targets, or, if <code>ntrans&gt;1</code>,          a matrix of size <code>(nk,ntrans)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ludvigak/FINUFFT.jl/blob/a917b2427c04780474b9be927889e86f5d3aef62/src/simple.jl#L389-L423">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 2 November 2021 14:59">Tuesday 2 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
